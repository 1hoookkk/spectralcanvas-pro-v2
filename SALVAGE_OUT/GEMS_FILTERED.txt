C:\spectralCanvas Pro\build_minimal\MinimalTest.cpp:2:#include <juce_audio_plugin_client/juce_audio_plugin_client.h>
C:\spectralCanvas Pro\build_minimal\MinimalTest.cpp:4:class MinimalTestEditor : public juce::AudioProcessorEditor
C:\spectralCanvas Pro\build_minimal\MinimalTest.cpp:12:void paint(juce::Graphics& g) override
C:\spectralCanvas Pro\build_minimal\MinimalTest.cpp:14:g.fillAll(juce::Colours::black);
C:\spectralCanvas Pro\build_minimal\MinimalTest.cpp:15:g.setColour(juce::Colours::white);
C:\spectralCanvas Pro\build_minimal\MinimalTest.cpp:16:g.drawFittedText("Minimal Test Plugin", getLocalBounds(), juce::Justification::centred, 1);
C:\spectralCanvas Pro\build_minimal\MinimalTest.cpp:23:JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(MinimalTestEditor)
C:\spectralCanvas Pro\build_minimal\MinimalTest.cpp:28:.withInput("Input", juce::AudioChannelSet::stereo(), true)
C:\spectralCanvas Pro\build_minimal\MinimalTest.cpp:29:.withOutput("Output", juce::AudioChannelSet::stereo(), true))
C:\spectralCanvas Pro\build_minimal\MinimalTest.cpp:39:juce::ignoreUnused(sampleRate, samplesPerBlock);
C:\spectralCanvas Pro\build_minimal\MinimalTest.cpp:46:void MinimalTestProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
C:\spectralCanvas Pro\build_minimal\MinimalTest.cpp:48:juce::ignoreUnused(midiMessages);
C:\spectralCanvas Pro\build_minimal\MinimalTest.cpp:49:juce::ScopedNoDenormals noDenormals;
C:\spectralCanvas Pro\build_minimal\MinimalTest.cpp:52:auto totalNumInputChannels = getTotalNumInputChannels();
C:\spectralCanvas Pro\build_minimal\MinimalTest.cpp:53:auto totalNumOutputChannels = getTotalNumOutputChannels();
C:\spectralCanvas Pro\build_minimal\MinimalTest.cpp:55:for (auto i = totalNumInputChannels; i < totalNumOutputChannels; ++i)
C:\spectralCanvas Pro\build_minimal\MinimalTest.cpp:59:juce::AudioProcessorEditor* MinimalTestProcessor::createEditor()
C:\spectralCanvas Pro\build_minimal\MinimalTest.cpp:64:void MinimalTestProcessor::getStateInformation(juce::MemoryBlock& destData)
C:\spectralCanvas Pro\build_minimal\MinimalTest.cpp:66:juce::ignoreUnused(destData);
C:\spectralCanvas Pro\build_minimal\MinimalTest.cpp:71:juce::ignoreUnused(data, sizeInBytes);
C:\spectralCanvas Pro\build_minimal\MinimalTest.cpp:75:juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
C:\spectralCanvas Pro\build_minimal\MinimalTest.h:2:#include <juce_audio_processors/juce_audio_processors.h>
C:\spectralCanvas Pro\build_minimal\MinimalTest.h:4:class MinimalTestProcessor : public juce::AudioProcessor
C:\spectralCanvas Pro\build_minimal\MinimalTest.h:12:void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) noexcept override;
C:\spectralCanvas Pro\build_minimal\MinimalTest.h:14:juce::AudioProcessorEditor* createEditor() override;
C:\spectralCanvas Pro\build_minimal\MinimalTest.h:17:const juce::String getName() const override { return "MinimalTest"; }
C:\spectralCanvas Pro\build_minimal\MinimalTest.h:25:void setCurrentProgram(int index) override { juce::ignoreUnused(index); }
C:\spectralCanvas Pro\build_minimal\MinimalTest.h:26:const juce::String getProgramName(int index) override { juce::ignoreUnused(index); return {}; }
C:\spectralCanvas Pro\build_minimal\MinimalTest.h:27:void changeProgramName(int index, const juce::String& newName) override { juce::ignoreUnused(index, newName); }
C:\spectralCanvas Pro\build_minimal\MinimalTest.h:29:void getStateInformation(juce::MemoryBlock& destData) override;
C:\spectralCanvas Pro\build_minimal\MinimalTest.h:33:JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(MinimalTestProcessor)
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:3:#include <juce_audio_processors/juce_audio_processors.h>
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:28:int queueDepthAudioToUI = 0;          // Spectral data queue depth
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:31:int dropCountAudioToUI = 0;           // Dropped spectral frames
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:34:uint64_t totalSamplesProcessed = 0;   // Cumulative samples
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:71:void recordSamplesProcessed(int numSamples) noexcept;
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:85:static void assertAudioThread() noexcept;
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:86:static void assertNotAudioThread() noexcept;
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:143:* RT-safety assertions for debug builds
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:145:#ifdef JUCE_DEBUG
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:146:#define RT_ASSERT_AUDIO_THREAD() ContinuousVerification::assertAudioThread()
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:147:#define RT_ASSERT_NOT_AUDIO_THREAD() ContinuousVerification::assertNotAudioThread()
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:151:#define RT_ASSERT_AUDIO_THREAD() ((void)0)
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:152:#define RT_ASSERT_NOT_AUDIO_THREAD() ((void)0)
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:158:* For validating STFT/iFFT and paint-to-audio consistency
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:165:bool passed = false;
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:171:// Test STFT round-trip accuracy
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:172:static TestResult testSTFTRoundTrip(int fftSize, int hopSize, int numSamples);
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:223:bool passed = false;
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:225:int numPassed = 0;
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:280:#ifdef JUCE_DEBUG
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:7:// Lock-free single-producer single-consumer (SPSC) queue for RT-safe communication
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:8:// Based on Dmitry Vyukov's bounded SPSC queue design
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:10:class SPSCQueue
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:12:static_assert((Size & (Size - 1)) == 0, "Size must be power of 2");
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:13:static_assert(std::is_trivially_copyable_v<T>, "Type must be trivially copyable for RT-safety");
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:16:SPSCQueue() noexcept : head_(0), tail_(0) {}
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:19:SPSCQueue(const SPSCQueue&) = delete;
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:20:SPSCQueue& operator=(const SPSCQueue&) = delete;
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:85:// Spectral data frame for Audio Thread → UI Thread communication
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:86:struct SpectralFrame
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:88:static constexpr size_t FFT_SIZE = 512;
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:89:static constexpr size_t NUM_BINS = FFT_SIZE / 2 + 1; // 257 bins for real FFT
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:91:alignas(32) float magnitude[NUM_BINS];    // Spectral magnitudes
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:92:alignas(32) float phase[NUM_BINS];        // Spectral phases
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:97:float spectralCentroid;                   // Brightness measure
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:99:SpectralFrame() noexcept
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:106:spectralCentroid = 0.0f;
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:133:UpdateColormap = 4,
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:146:struct { int colormapType; } colormapData;
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:165:UpdateSpectralTexture = 0,
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:176:SpectralFrame spectralData;           // For spectral texture updates
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:186:RenderCommand() noexcept : commandType(UpdateSpectralTexture), sequenceNumber(0) {}
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:190:using SpectralDataQueue = SPSCQueue<SpectralFrame, 16>;      // Audio → UI
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:191:using ParameterQueue = SPSCQueue<ParameterUpdate, 64>;       // UI → Audio
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:192:using RenderCommandQueue = SPSCQueue<RenderCommand, 32>;     // UI → GPU
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:193:using GestureCommandQueue = SPSCQueue<GestureCommand, 128>;  // UI → GPU (high frequency)
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:195:// RT-safe assertions for debug builds
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:196:#ifdef JUCE_DEBUG
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:197:#define RT_SAFE_ASSERT(condition) juce_assert(condition)
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:198:#define RT_SAFE_LOG(message) juce::Logger::writeToLog("[RT-SAFE] " message)
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:200:#define RT_SAFE_ASSERT(condition) ((void)0)
C:\spectralCanvas Pro\Source\Core\MessageBus.h:13:// Simple SPSC Ring Buffer (lock-free, RT-safe)
C:\spectralCanvas Pro\Source\Core\MessageBus.h:15:class SpscRing
C:\spectralCanvas Pro\Source\Core\MessageBus.h:18:static_assert((CapacityPow2 & (CapacityPow2 - 1)) == 0, "Capacity must be power of two");
C:\spectralCanvas Pro\Source\Core\MessageBus.h:19:static_assert(std::is_trivially_copyable_v<T>, "T must be trivially copyable (POD) for RT safety");
C:\spectralCanvas Pro\Source\Core\MessageBus.h:22:SpscRing(const SpscRing&) = delete;
C:\spectralCanvas Pro\Source\Core\MessageBus.h:23:SpscRing& operator=(const SpscRing&) = delete;
C:\spectralCanvas Pro\Source\Core\MessageBus.h:24:SpscRing(SpscRing&&) = delete;
C:\spectralCanvas Pro\Source\Core\MessageBus.h:25:SpscRing& operator=(SpscRing&&) = delete;
C:\spectralCanvas Pro\Source\Core\MessageBus.h:27:SpscRing() = default;
C:\spectralCanvas Pro\Source\Core\MessageBus.h:98:// Spectral data frame for Audio Thread → UI Thread communication
C:\spectralCanvas Pro\Source\Core\MessageBus.h:104:struct SpectralFrame
C:\spectralCanvas Pro\Source\Core\MessageBus.h:106:static constexpr size_t FFT_SIZE = 512;
C:\spectralCanvas Pro\Source\Core\MessageBus.h:107:static constexpr size_t NUM_BINS = FFT_SIZE / 2 + 1; // 257 bins for real FFT
C:\spectralCanvas Pro\Source\Core\MessageBus.h:109:alignas(32) float magnitude[NUM_BINS];    // Spectral magnitudes
C:\spectralCanvas Pro\Source\Core\MessageBus.h:110:alignas(32) float phase[NUM_BINS];        // Spectral phases
C:\spectralCanvas Pro\Source\Core\MessageBus.h:117:float spectralCentroid;                   // Brightness measure
C:\spectralCanvas Pro\Source\Core\MessageBus.h:119:SpectralFrame() noexcept
C:\spectralCanvas Pro\Source\Core\MessageBus.h:128:spectralCentroid = 0.0f;
C:\spectralCanvas Pro\Source\Core\MessageBus.h:163:static constexpr size_t MAX_BINS = 1024; // Support up to 2048 FFT (1024 bins)
C:\spectralCanvas Pro\Source\Core\MessageBus.h:166:uint32_t frameIndex;                     // FFT frame this applies to
C:\spectralCanvas Pro\Source\Core\MessageBus.h:193:// DIAGNOSTIC: Static asserts to freeze MaskColumn layout and detect instance mismatch
C:\spectralCanvas Pro\Source\Core\MessageBus.h:194:static_assert(std::is_trivially_copyable_v<MaskColumn>, "MaskColumn must be POD for queue safety");
C:\spectralCanvas Pro\Source\Core\MessageBus.h:195:static_assert(alignof(MaskColumn) == 32, "MaskColumn alignment changed - potential cache issues");
C:\spectralCanvas Pro\Source\Core\MessageBus.h:196:static_assert(offsetof(MaskColumn, values) == 0, "values array must be at offset 0");
C:\spectralCanvas Pro\Source\Core\MessageBus.h:204:using SpectralDataQueue = SpscRing<SpectralFrame, 16>;      // Audio → UI
C:\spectralCanvas Pro\Source\Core\MessageBus.h:205:using ParameterQueue = SpscRing<ParameterUpdate, 64>;       // UI → Audio
C:\spectralCanvas Pro\Source\Core\MessageBus.h:206:using MaskColumnQueue = SpscRing<MaskColumn, 8>;            // GPU → Audio
C:\spectralCanvas Pro\Source\Core\MessageBus.h:208:// RT-safe assertions for debug builds
C:\spectralCanvas Pro\Source\Core\MessageBus.h:209:#ifdef JUCE_DEBUG
C:\spectralCanvas Pro\Source\Core\MessageBus.h:210:#define RT_SAFE_ASSERT(condition) juce_assert(condition)
C:\spectralCanvas Pro\Source\Core\MessageBus.h:211:#define RT_SAFE_LOG(message) juce::Logger::writeToLog("[RT-SAFE] " message)
C:\spectralCanvas Pro\Source\Core\MessageBus.h:213:#define RT_SAFE_ASSERT(condition) ((void)0)
C:\spectralCanvas Pro\Source\Core\PaintQueue.h:5:#include <juce_core/juce_core.h>
C:\spectralCanvas Pro\Source\Core\PaintQueue.h:8:* Lock-free Single Producer Single Consumer (SPSC) queue for paint events
C:\spectralCanvas Pro\Source\Core\PaintQueue.h:49:static_assert((Capacity & (Capacity-1)) == 0, "Capacity must be power of 2");
C:\spectralCanvas Pro\Source\Core\PaintQueue.h:50:static_assert(Capacity >= 16, "Minimum capacity of 16 for reasonable buffering");
C:\spectralCanvas Pro\Source\Core\PaintQueue.h:51:static_assert(Capacity <= 16384, "Maximum capacity of 16384 to prevent excessive memory usage");
C:\spectralCanvas Pro\Source\Core\PaintQueue.h:56:// Delete copy operations (lock-free structures must not be copied)
C:\spectralCanvas Pro\Source\Core\PaintQueue.h:179:using SpectralPaintQueue = PaintQueue<PaintEvent, 4096>;    // UI → Audio paint events
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:3:#include <juce_dsp/juce_dsp.h>
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:17:uint8_t audioPath;                    // AudioPath enum (0=Silent, 1=TestFeeder, 2=Phase4Synth, 3=SpectralEngine)
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:19:bool useFullSpectralEngine;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:23:float spectralGain;                   // 0..2 (needs ramping)
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:24:float spectralMix;                    // 0..1 (needs ramping)
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:30:uint16_t fftSize;                     // 256, 512, 1024, 2048
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:31:uint16_t hopSize;                     // FFT_SIZE/4 typically
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:35:// Z-Plane filter parameters
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:40:float zPlaneMorphX;                   // 0..1
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:41:float zPlaneMorphY;                   // 0..1
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:49:// Tube saturation
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:50:float saturationDrive;                // 0..10
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:51:float saturationMix;                  // 0..1
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:52:bool saturationOversampling;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:57:uint8_t rootNote;                     // 0-11 pitch classes
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:63:// Visual parameters (passed to GPU thread)
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:64:uint8_t colormapType;                 // 0=Viridis, 1=Magma, 2=Purple_Cyan
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:86:useFullSpectralEngine = false;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:89:spectralGain = 1.0f;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:90:spectralMix = 1.0f;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:95:fftSize = 512;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:104:zPlaneMorphX = 0.5f;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:105:zPlaneMorphY = 0.5f;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:112:saturationDrive = 1.0f;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:113:saturationMix = 0.3f;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:114:saturationOversampling = false;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:123:colormapType = 2; // Purple_Cyan
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:141:static_assert(std::is_trivially_copyable_v<ParameterSnapshot>,
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:147:* Uses JUCE's SmoothedValue for parameters that need ramping to avoid clicks/steps
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:163:spectralGain.setTargetValue(1.0f);
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:164:spectralGain.reset(sampleRate, rampTimeMs / 1000.0f);
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:166:spectralMix.setTargetValue(1.0f);
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:167:spectralMix.reset(sampleRate, rampTimeMs / 1000.0f);
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:182:spectralGain.setCurrentAndTargetValue(1.0f);
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:183:spectralMix.setCurrentAndTargetValue(1.0f);
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:193:const float gainLinear = juce::Decibels::decibelsToGain(
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:194:juce::jmap(snapshot.masterGain, -24.0f, 24.0f));
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:197:spectralGain.setTargetValue(snapshot.spectralGain);
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:198:spectralMix.setTargetValue(snapshot.spectralMix);
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:206:float getSpectralGain() noexcept { return spectralGain.getNextValue(); }
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:207:float getSpectralMix() noexcept { return spectralMix.getNextValue(); }
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:216:spectralGain.skip(numSamples);
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:217:spectralMix.skip(numSamples);
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:225:juce::SmoothedValue<float> masterGain;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:226:juce::SmoothedValue<float> spectralGain;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:227:juce::SmoothedValue<float> spectralMix;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:228:juce::SmoothedValue<float> blend;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:229:juce::SmoothedValue<float> oscGain;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:230:juce::SmoothedValue<float> maskDepth;
C:\spectralCanvas Pro\Source\Core\Params.h:3:#include <juce_audio_processors/juce_audio_processors.h>
C:\spectralCanvas Pro\Source\Core\Params.h:12:const juce::String mode = "mode";                     // 0=Synth, 1=Resynth, 2=Hybrid
C:\spectralCanvas Pro\Source\Core\Params.h:13:const juce::String blend = "blend";                   // 0..1 (0=synth only, 1=resynth only)
C:\spectralCanvas Pro\Source\Core\Params.h:14:const juce::String respeed = "respeed";               // 0.25..4.0 (resynth playback speed)
C:\spectralCanvas Pro\Source\Core\Params.h:17:const juce::String brushType = "brush_type";          // 0=Paint, 1=Quantize, 2=Erase, 3=Comb
C:\spectralCanvas Pro\Source\Core\Params.h:18:const juce::String brushSize = "brush_size";          // 1..128 bins
C:\spectralCanvas Pro\Source\Core\Params.h:19:const juce::String brushStrength = "brush_strength";  // 0..1
C:\spectralCanvas Pro\Source\Core\Params.h:20:const juce::String quantizeStrength = "quantize_strength"; // 0..1
C:\spectralCanvas Pro\Source\Core\Params.h:23:const juce::String gridOn = "grid_on";
C:\spectralCanvas Pro\Source\Core\Params.h:24:const juce::String tuningId = "tuning_id";            // 0=12TET, custom N-EDO...
C:\spectralCanvas Pro\Source\Core\Params.h:26:// Z-Plane Morph Parameters
C:\spectralCanvas Pro\Source\Core\Params.h:27:const juce::String zPlaneMorphX = "zplane_morph_x";   // 0..1
C:\spectralCanvas Pro\Source\Core\Params.h:28:const juce::String zPlaneMorphY = "zplane_morph_y";   // 0..1
C:\spectralCanvas Pro\Source\Core\Params.h:30:// Spectral Processing Parameters
C:\spectralCanvas Pro\Source\Core\Params.h:31:const juce::String spectralGain = "spectral_gain";
C:\spectralCanvas Pro\Source\Core\Params.h:32:const juce::String spectralMix = "spectral_mix";
C:\spectralCanvas Pro\Source\Core\Params.h:33:const juce::String fftSize = "fft_size";
C:\spectralCanvas Pro\Source\Core\Params.h:34:const juce::String hopSize = "hop_size";
C:\spectralCanvas Pro\Source\Core\Params.h:36:// Z-Plane Filter Parameters
C:\spectralCanvas Pro\Source\Core\Params.h:37:const juce::String filterType = "filter_type";       // 0.0=LP, 0.5=BP, 1.0=HP
C:\spectralCanvas Pro\Source\Core\Params.h:38:const juce::String filterCutoff = "filter_cutoff";
C:\spectralCanvas Pro\Source\Core\Params.h:39:const juce::String filterResonance = "filter_resonance";
C:\spectralCanvas Pro\Source\Core\Params.h:40:const juce::String filterMorphAmount = "filter_morph_amount";
C:\spectralCanvas Pro\Source\Core\Params.h:42:// Tube Saturation Parameters
C:\spectralCanvas Pro\Source\Core\Params.h:43:const juce::String saturationDrive = "saturation_drive";
C:\spectralCanvas Pro\Source\Core\Params.h:44:const juce::String saturationMix = "saturation_mix";
C:\spectralCanvas Pro\Source\Core\Params.h:45:const juce::String saturationOversampling = "saturation_oversampling";
C:\spectralCanvas Pro\Source\Core\Params.h:48:const juce::String colormapType = "colormap_type";   // 0=Viridis, 1=Magma, 2=Purple_Cyan
C:\spectralCanvas Pro\Source\Core\Params.h:49:const juce::String particleCount = "particle_count";
C:\spectralCanvas Pro\Source\Core\Params.h:50:const juce::String animationSpeed = "animation_speed";
C:\spectralCanvas Pro\Source\Core\Params.h:53:const juce::String fastPaintMode = "fast_paint_mode"; // Low-latency mode for interaction
C:\spectralCanvas Pro\Source\Core\Params.h:54:const juce::String gpuAcceleration = "gpu_acceleration";
C:\spectralCanvas Pro\Source\Core\Params.h:57:const juce::String testModeActive = "test_mode_active"; // Start/Stop test toggle
C:\spectralCanvas Pro\Source\Core\Params.h:58:const juce::String maskDepth = "mask_depth";           // 0..1 mask intensity
C:\spectralCanvas Pro\Source\Core\Params.h:59:const juce::String debugOverlayEnabled = "debug_overlay_enabled"; // Debug overlay toggle
C:\spectralCanvas Pro\Source\Core\Params.h:60:const juce::String visualGamma = "visual_gamma";       // 0.5..1.5 display gamma (Phase 3)
C:\spectralCanvas Pro\Source\Core\Params.h:61:const juce::String visualGain = "visual_gain";         // 0..4 display gain (Phase 3)
C:\spectralCanvas Pro\Source\Core\Params.h:62:const juce::String freezeDisplay = "freeze_display";   // Freeze/scroll toggle (Phase 3)
C:\spectralCanvas Pro\Source\Core\Params.h:65:const juce::String gain = "gain";                     // -24..+24 dB master gain
C:\spectralCanvas Pro\Source\Core\Params.h:68:const juce::String useTestFeeder = "use_test_feeder";         // Rollback to old system
C:\spectralCanvas Pro\Source\Core\Params.h:69:const juce::String keyFilterEnabled = "key_filter_enabled";   // Enable key filter
C:\spectralCanvas Pro\Source\Core\Params.h:70:const juce::String scaleType = "scale_type";                  // 0=Chromatic, 1=Major, 2=Minor
C:\spectralCanvas Pro\Source\Core\Params.h:71:const juce::String rootNote = "root_note";                    // 0-11 pitch classes
C:\spectralCanvas Pro\Source\Core\Params.h:72:const juce::String oscGain = "osc_gain";                      // 0-1 oscillator gain
C:\spectralCanvas Pro\Source\Core\Params.h:79:const juce::NormalisableRange<float> modeRange(0.0f, 2.0f, 1.0f);
C:\spectralCanvas Pro\Source\Core\Params.h:82:const juce::NormalisableRange<float> blendRange(0.0f, 1.0f, 0.01f);
C:\spectralCanvas Pro\Source\Core\Params.h:85:const juce::NormalisableRange<float> respeedRange(0.25f, 4.0f, 0.01f);
C:\spectralCanvas Pro\Source\Core\Params.h:89:const juce::NormalisableRange<float> brushTypeRange(0.0f, 3.0f, 1.0f);
C:\spectralCanvas Pro\Source\Core\Params.h:92:const juce::NormalisableRange<float> brushSizeRange(1.0f, 128.0f, 1.0f);
C:\spectralCanvas Pro\Source\Core\Params.h:95:const juce::NormalisableRange<float> brushStrengthRange(0.0f, 1.0f, 0.01f);
C:\spectralCanvas Pro\Source\Core\Params.h:98:const juce::NormalisableRange<float> quantizeStrengthRange(0.0f, 1.0f, 0.01f);
C:\spectralCanvas Pro\Source\Core\Params.h:102:const juce::NormalisableRange<float> tuningIdRange(0.0f, 10.0f, 1.0f);
C:\spectralCanvas Pro\Source\Core\Params.h:105:// Z-Plane Morph
C:\spectralCanvas Pro\Source\Core\Params.h:106:const juce::NormalisableRange<float> zPlaneMorphRange(0.0f, 1.0f, 0.01f);
C:\spectralCanvas Pro\Source\Core\Params.h:107:const float zPlaneMorphXDefault = 0.5f;
C:\spectralCanvas Pro\Source\Core\Params.h:108:const float zPlaneMorphYDefault = 0.5f;
C:\spectralCanvas Pro\Source\Core\Params.h:110:// Spectral Processing
C:\spectralCanvas Pro\Source\Core\Params.h:111:const juce::NormalisableRange<float> spectralGainRange(0.0f, 2.0f, 0.01f);
C:\spectralCanvas Pro\Source\Core\Params.h:112:const float spectralGainDefault = 1.0f;
C:\spectralCanvas Pro\Source\Core\Params.h:114:const juce::NormalisableRange<float> spectralMixRange(0.0f, 1.0f, 0.01f);
C:\spectralCanvas Pro\Source\Core\Params.h:115:const float spectralMixDefault = 1.0f;
C:\spectralCanvas Pro\Source\Core\Params.h:117:const juce::NormalisableRange<float> fftSizeRange(256.0f, 2048.0f, 1.0f);
C:\spectralCanvas Pro\Source\Core\Params.h:118:const float fftSizeDefault = 512.0f;
C:\spectralCanvas Pro\Source\Core\Params.h:120:// Z-Plane Filter
C:\spectralCanvas Pro\Source\Core\Params.h:121:const juce::NormalisableRange<float> filterTypeRange(0.0f, 1.0f, 0.01f);
C:\spectralCanvas Pro\Source\Core\Params.h:124:const juce::NormalisableRange<float> filterCutoffRange(20.0f, 20000.0f, 1.0f);
C:\spectralCanvas Pro\Source\Core\Params.h:127:const juce::NormalisableRange<float> filterResonanceRange(0.1f, 10.0f, 0.01f);
C:\spectralCanvas Pro\Source\Core\Params.h:130:// Tube Saturation
C:\spectralCanvas Pro\Source\Core\Params.h:131:const juce::NormalisableRange<float> saturationDriveRange(0.0f, 10.0f, 0.01f);
C:\spectralCanvas Pro\Source\Core\Params.h:132:const float saturationDriveDefault = 1.0f;
C:\spectralCanvas Pro\Source\Core\Params.h:134:const juce::NormalisableRange<float> saturationMixRange(0.0f, 1.0f, 0.01f);
C:\spectralCanvas Pro\Source\Core\Params.h:135:const float saturationMixDefault = 0.3f;
C:\spectralCanvas Pro\Source\Core\Params.h:138:const juce::NormalisableRange<float> colormapTypeRange(0.0f, 2.0f, 1.0f);
C:\spectralCanvas Pro\Source\Core\Params.h:139:const float colormapTypeDefault = 2.0f; // Purple_Cyan (nebula default)
C:\spectralCanvas Pro\Source\Core\Params.h:141:const juce::NormalisableRange<float> particleCountRange(100.0f, 5000.0f, 10.0f);
C:\spectralCanvas Pro\Source\Core\Params.h:146:const juce::NormalisableRange<float> maskDepthRange(0.0f, 1.0f, 0.01f);
C:\spectralCanvas Pro\Source\Core\Params.h:148:const juce::NormalisableRange<float> visualGammaRange(0.5f, 1.5f, 0.01f);
C:\spectralCanvas Pro\Source\Core\Params.h:151:const juce::NormalisableRange<float> visualGainRange(0.0f, 4.0f, 0.01f);
C:\spectralCanvas Pro\Source\Core\Params.h:155:const juce::NormalisableRange<float> gainRange(-24.0f, 24.0f, 0.01f);
C:\spectralCanvas Pro\Source\Core\Params.h:161:const juce::NormalisableRange<float> scaleTypeRange(0.0f, 2.0f, 1.0f);
C:\spectralCanvas Pro\Source\Core\Params.h:163:const juce::NormalisableRange<float> rootNoteRange(0.0f, 11.0f, 1.0f);
C:\spectralCanvas Pro\Source\Core\Params.h:165:const juce::NormalisableRange<float> oscGainRange(0.0f, 1.0f, 0.01f);
C:\spectralCanvas Pro\Source\Core\Params.h:170:inline juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout()
C:\spectralCanvas Pro\Source\Core\Params.h:172:std::vector<std::unique_ptr<juce::RangedAudioParameter>> parameters;
C:\spectralCanvas Pro\Source\Core\Params.h:175:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:179:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:183:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:188:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:192:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:196:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:200:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:205:parameters.push_back(std::make_unique<juce::AudioParameterBool>(
C:\spectralCanvas Pro\Source\Core\Params.h:208:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:212:// Z-Plane Morph Parameters
C:\spectralCanvas Pro\Source\Core\Params.h:213:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:214:ParameterIDs::zPlaneMorphX, "Z-Plane Morph X",
C:\spectralCanvas Pro\Source\Core\Params.h:215:ParameterRanges::zPlaneMorphRange, ParameterRanges::zPlaneMorphXDefault));
C:\spectralCanvas Pro\Source\Core\Params.h:217:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:218:ParameterIDs::zPlaneMorphY, "Z-Plane Morph Y",
C:\spectralCanvas Pro\Source\Core\Params.h:219:ParameterRanges::zPlaneMorphRange, ParameterRanges::zPlaneMorphYDefault));
C:\spectralCanvas Pro\Source\Core\Params.h:221:// Spectral Processing Parameters
C:\spectralCanvas Pro\Source\Core\Params.h:222:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:223:ParameterIDs::spectralGain, "Spectral Gain",
C:\spectralCanvas Pro\Source\Core\Params.h:224:ParameterRanges::spectralGainRange, ParameterRanges::spectralGainDefault));
C:\spectralCanvas Pro\Source\Core\Params.h:226:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:227:ParameterIDs::spectralMix, "Spectral Mix",
C:\spectralCanvas Pro\Source\Core\Params.h:228:ParameterRanges::spectralMixRange, ParameterRanges::spectralMixDefault));
C:\spectralCanvas Pro\Source\Core\Params.h:230:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:231:ParameterIDs::fftSize, "FFT Size",
C:\spectralCanvas Pro\Source\Core\Params.h:232:ParameterRanges::fftSizeRange, ParameterRanges::fftSizeDefault));
C:\spectralCanvas Pro\Source\Core\Params.h:234:// Z-Plane Filter Parameters
C:\spectralCanvas Pro\Source\Core\Params.h:235:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:239:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:243:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:247:// Tube Saturation Parameters
C:\spectralCanvas Pro\Source\Core\Params.h:248:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:249:ParameterIDs::saturationDrive, "Saturation Drive",
C:\spectralCanvas Pro\Source\Core\Params.h:250:ParameterRanges::saturationDriveRange, ParameterRanges::saturationDriveDefault));
C:\spectralCanvas Pro\Source\Core\Params.h:252:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:253:ParameterIDs::saturationMix, "Saturation Mix",
C:\spectralCanvas Pro\Source\Core\Params.h:254:ParameterRanges::saturationMixRange, ParameterRanges::saturationMixDefault));
C:\spectralCanvas Pro\Source\Core\Params.h:257:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:258:ParameterIDs::colormapType, "Colormap Type",
C:\spectralCanvas Pro\Source\Core\Params.h:259:ParameterRanges::colormapTypeRange, ParameterRanges::colormapTypeDefault));
C:\spectralCanvas Pro\Source\Core\Params.h:261:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:266:parameters.push_back(std::make_unique<juce::AudioParameterBool>(
C:\spectralCanvas Pro\Source\Core\Params.h:269:parameters.push_back(std::make_unique<juce::AudioParameterBool>(
C:\spectralCanvas Pro\Source\Core\Params.h:273:parameters.push_back(std::make_unique<juce::AudioParameterBool>(
C:\spectralCanvas Pro\Source\Core\Params.h:276:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:280:parameters.push_back(std::make_unique<juce::AudioParameterBool>(
C:\spectralCanvas Pro\Source\Core\Params.h:283:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:287:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:291:parameters.push_back(std::make_unique<juce::AudioParameterBool>(
C:\spectralCanvas Pro\Source\Core\Params.h:295:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:300:parameters.push_back(std::make_unique<juce::AudioParameterBool>(
C:\spectralCanvas Pro\Source\Core\Params.h:304:parameters.push_back(std::make_unique<juce::AudioParameterBool>(
C:\spectralCanvas Pro\Source\Core\Params.h:308:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:312:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\Params.h:316:parameters.push_back(std::make_unique<juce::AudioParameterFloat>(
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:4:void SpectralCanvasProAudioProcessor::processBlock(juce::AudioBuffer<float>& buffer,
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:5:juce::MidiBuffer& midiMessages) noexcept
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:7:juce::ignoreUnused(midiMessages);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:10:juce::ScopedNoDenormals noDenormals;
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:11:juce::AudioProcessLoadMeasurer::ScopedTimer loadTimer(loadMeasurer_);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:14:const int numChannels = buffer.getNumChannels();
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:35:// Pattern #1: Route to pure DSP engine (no JUCE types)
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:42:// Core engine processes with parameter snapshot (pure DSP)
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:43:coreEngine->process(inputPtrs, outputPtrs, numChannels, numSamples, currentSnapshot);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:56:totalProcessedSamples_.fetch_add(numSamples, std::memory_order_relaxed);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:64:void SpectralCanvasProAudioProcessor::updateTimebase() noexcept
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:66:// Read playhead position ONLY here (JUCE playhead is only valid in processBlock)
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:70:juce::AudioPlayHead::CurrentPositionInfo positionInfo;
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:80:const uint64_t totalSamples = totalProcessedSamples_.load(std::memory_order_relaxed);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:85:void SpectralCanvasProAudioProcessor::buildParameterSnapshot() noexcept
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:92:auto* spectralGainParam = apvts.getRawParameterValue(Params::ParameterIDs::spectralGain);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:93:auto* spectralMixParam = apvts.getRawParameterValue(Params::ParameterIDs::spectralMix);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:96:auto* fftSizeParam = apvts.getRawParameterValue(Params::ParameterIDs::fftSize);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:101:currentSnapshot.spectralGain = spectralGainParam ? spectralGainParam->load() : 1.0f;
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:102:currentSnapshot.spectralMix = spectralMixParam ? spectralMixParam->load() : 1.0f;
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:105:currentSnapshot.fftSize = fftSizeParam ? static_cast<uint16_t>(fftSizeParam->load()) : 512;
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:113:if (useFullSpectralEngine_.load(std::memory_order_relaxed))
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:114:currentSnapshot.audioPath = static_cast<uint8_t>(AudioPath::SpectralEngine);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:122:void SpectralCanvasProAudioProcessor::processQueuedCommands() noexcept
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:154:void SpectralCanvasProAudioProcessor::setProcessing(bool isNowPlaying)
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:164:if (spectralEngine) spectralEngine->reset();
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:167:spectralDataQueue.clear();
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:177:void SpectralCanvasProAudioProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:191:coreEngine = std::make_unique<SpectralCoreEngine>();
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:196:config.fftSize = ReconfigManager::FFTSize::Size512;
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:198:config.numChannels = getTotalNumOutputChannels();
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:207:if (!spectralEngine)
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:209:spectralEngine = std::make_unique<SpectralEngine>();
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:210:spectralEngine->initialize(sampleRate, samplesPerBlock);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:214:spectralStub.prepare(sampleRate, 512, 257, getTotalNumOutputChannels());
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:219:void SpectralCanvasProAudioProcessor::applyParameterUpdate(const ParameterUpdate& update) noexcept
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:233:void SpectralCanvasProAudioProcessor::processLegacyPath(juce::AudioBuffer<float>& buffer, int numSamples) noexcept
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:252:spectralStub.popAllMaskColumnsInto(maskColumnQueue);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:253:spectralStub.process(buffer, oscGain_.load(std::memory_order_relaxed));
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:257:case AudioPath::SpectralEngine:
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:258:// Use full spectral engine
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:259:if (spectralEngine && spectralEngine->isInitialized())
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:261:spectralEngine->processBlock(
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:274:void SpectralCanvasProAudioProcessor::publishTelemetry(const SpectralCoreEngine::EngineStateSnapshot& snapshot) noexcept
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:276:// Create spectral frame for UI
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:277:SpectralFrame frame;
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:282:frame.spectralCentroid = snapshot.spectralCentroid;
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:284:// Extract spectral data from engine
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:287:coreEngine->extractSpectralData(frame.magnitude, frame.phase, SpectralFrame::NUM_BINS);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:291:spectralDataQueue.push(frame);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:295:void SpectralCanvasProAudioProcessor::generateTestTone(juce::AudioBuffer<float>& buffer, int numSamples) noexcept
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:299:const float increment = juce::MathConstants<float>::twoPi * freq / static_cast<float>(currentSampleRate);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:304:for (int channel = 0; channel < buffer.getNumChannels(); ++channel)
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:306:buffer.setSample(channel, sample, value);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:310:if (phase >= juce::MathConstants<float>::twoPi)
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:311:phase -= juce::MathConstants<float>::twoPi;
C:\spectralCanvas Pro\Source\Core\RealtimeSafeTypes.h:12:// RT-safe assertions for debug builds
C:\spectralCanvas Pro\Source\Core\RealtimeSafeTypes.h:13:#ifdef JUCE_DEBUG
C:\spectralCanvas Pro\Source\Core\RealtimeSafeTypes.h:14:#define RT_SAFE_ASSERT(condition) juce_assert(condition)
C:\spectralCanvas Pro\Source\Core\RealtimeSafeTypes.h:15:#define RT_SAFE_LOG(message) juce::Logger::writeToLog("[RT-SAFE] " message)
C:\spectralCanvas Pro\Source\Core\RealtimeSafeTypes.h:17:#define RT_SAFE_ASSERT(condition) ((void)0)
C:\spectralCanvas Pro\Source\Core\RealtimeSafeTypes.h:63:static_assert((Size & (Size - 1)) == 0, "Size must be power of 2 for RT-safe operation");
C:\spectralCanvas Pro\Source\Core\RealtimeSafeTypes.h:64:static_assert(std::is_trivially_copyable_v<T>, "Type must be trivially copyable");
C:\spectralCanvas Pro\Source\Core\RealtimeSafeTypes.h:146:enum Type { Hann, Hamming, Blackman, Rectangular };
C:\spectralCanvas Pro\Source\Core\RealtimeSafeTypes.h:148:explicit RTWindow(Type type = Hann) noexcept
C:\spectralCanvas Pro\Source\Core\RealtimeSafeTypes.h:165:RT_SAFE_ASSERT(index < WindowSize);
C:\spectralCanvas Pro\Source\Core\RealtimeSafeTypes.h:178:case Hann:
C:\spectralCanvas Pro\Source\Core\RealtimeSafeTypes.h:194:case Blackman:
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:3:#include <juce_dsp/juce_dsp.h>
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:10:* ReconfigManager - Safe FFT/hop/latency reconfiguration system
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:12:* Handles reconfiguration of FFT parameters without allocating on the audio thread.
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:15:* Key principle: Never "live-flip" FFT parameters mid-callback - always pre-plan
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:21:// Supported FFT sizes (must be powers of 2)
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:22:enum class FFTSize : uint16_t
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:35:FFTSize fftSize = FFTSize::Size512;
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:36:int hopSize = 128;                    // FFT_SIZE/4 typically
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:37:int numChannels = 2;
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:38:bool enableOverlap = true;            // Overlap-add processing
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:41:int getFFTSizeInt() const noexcept { return static_cast<int>(fftSize); }
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:42:int getNumBins() const noexcept { return getFFTSizeInt() / 2 + 1; }
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:43:int getOverlapBufferSize() const noexcept { return getFFTSizeInt() * 4; }
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:46:// Pre-allocated FFT plan with buffers
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:47:struct FFTPlan
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:49:std::unique_ptr<juce::dsp::FFT> forwardFFT;
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:50:std::unique_ptr<juce::dsp::FFT> inverseFFT;
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:51:RTWindow<2048> hannWindow;            // Max window size
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:53:// Pre-allocated buffers (sized for largest FFT)
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:54:AlignedStorage<std::array<float, 2048>> fftBuffer;
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:55:AlignedStorage<std::array<float, 2048>> ifftBuffer;
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:57:AlignedStorage<std::array<float, 8192>> overlapBuffer; // FFT_SIZE * 4
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:62:FFTPlan() = default;
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:71:// Create FFT objects (this can allocate)
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:72:const int fftSizeInt = cfg.getFFTSizeInt();
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:73:const int fftOrder = static_cast<int>(std::log2(fftSizeInt));
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:75:forwardFFT = std::make_unique<juce::dsp::FFT>(fftOrder);
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:76:inverseFFT = std::make_unique<juce::dsp::FFT>(fftOrder);
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:78:// Initialize Hann window
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:79:// hannWindow.initialize(fftSizeInt);  // RTWindow doesn't have initialize method
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:82:std::fill(fftBuffer.data->begin(), fftBuffer.data->end(), 0.0f);
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:83:std::fill(ifftBuffer.data->begin(), ifftBuffer.data->end(), 0.0f);
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:101:// Clear overlap buffers but preserve FFT objects
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:171:// Get active FFT plan (RT-safe)
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:172:const FFTPlan& getActivePlan() const noexcept { return activePlan_; }
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:173:FFTPlan& getActivePlan() noexcept { return activePlan_; }
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:204:// JUCE prepareToPlay integration
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:220:// Typical STFT latency is hop size + processing delay
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:221:return currentConfig_.hopSize + (currentConfig_.getFFTSizeInt() / 4);
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:225:// Double-buffered FFT plans
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:226:FFTPlan activePlan_;                      // Currently used by audio thread
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:227:FFTPlan standbyPlan_;                     // Being prepared for swap
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:239:* Helper class for managing multiple cached FFT objects
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:240:* Avoids costly FFT construction by pre-caching common sizes
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:242:class FFTCache
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:245:static FFTCache& getInstance()
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:247:static FFTCache instance;
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:251:// Get cached FFT for specific size (may allocate on first request)
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:252:std::shared_ptr<juce::dsp::FFT> getForwardFFT(ReconfigManager::FFTSize size)
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:257:if (!forwardFFTs_[index])
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:259:const int fftOrder = static_cast<int>(std::log2(static_cast<int>(size)));
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:260:forwardFFTs_[index] = std::make_shared<juce::dsp::FFT>(fftOrder);
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:263:return forwardFFTs_[index];
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:266:std::shared_ptr<juce::dsp::FFT> getInverseFFT(ReconfigManager::FFTSize size)
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:271:if (!inverseFFTs_[index])
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:273:const int fftOrder = static_cast<int>(std::log2(static_cast<int>(size)));
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:274:inverseFFTs_[index] = std::make_shared<juce::dsp::FFT>(fftOrder);
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:277:return inverseFFTs_[index];
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:282:std::array<std::shared_ptr<juce::dsp::FFT>, NUM_SIZES> forwardFFTs_;
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:283:std::array<std::shared_ptr<juce::dsp::FFT>, NUM_SIZES> inverseFFTs_;
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:285:int getSizeIndex(ReconfigManager::FFTSize size) const
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:289:case ReconfigManager::FFTSize::Size256:  return 0;
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:290:case ReconfigManager::FFTSize::Size512:  return 1;
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:291:case ReconfigManager::FFTSize::Size1024: return 2;
C:\spectralCanvas Pro\Source\Core\ReconfigManager.h:292:case ReconfigManager::FFTSize::Size2048: return 3;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:13:* SpectralCoreEngine - Pure DSP engine with no JUCE dependencies
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:17:* Plugin wrapper classes handle JUCE integration and marshal data to/from engine.
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:19:class SpectralCoreEngine
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:26:uint64_t processedSamples;            // Total samples processed
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:28:int activeFFTSize;                    // Current FFT size
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:30:float peakMagnitude;                  // Current spectral peak
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:31:float spectralCentroid;               // Brightness measure
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:32:uint32_t maskColumnsProcessed;        // Paint events applied
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:42:SetFFTSize,
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:56:struct { uint16_t size; } fftSize;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:65:SpectralCoreEngine() noexcept;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:66:~SpectralCoreEngine() noexcept;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:69:SpectralCoreEngine(const SpectralCoreEngine&) = delete;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:70:SpectralCoreEngine& operator=(const SpectralCoreEngine&) = delete;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:78:int numChannels, int numSamples,
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:84:// Spectral data extraction (RT-safe)
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:85:bool extractSpectralData(float* magnitudes, float* phases, int maxBins) noexcept;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:105:std::atomic<uint64_t> processedSamples_{0};
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:110:int currentFFTSize_ = 512;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:115:void performSTFT(const float* input, int numSamples) noexcept;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:116:void performSpectralProcessing(const ParameterSnapshot& params) noexcept;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:117:void performiFFT(float* output, int numSamples) noexcept;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:120:// Pre-allocated RT-safe buffers (sized for max FFT)
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:121:static constexpr int MAX_FFT_SIZE = 2048;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:122:static constexpr int MAX_BINS = MAX_FFT_SIZE / 2 + 1;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:123:static constexpr int MAX_OVERLAP_SIZE = MAX_FFT_SIZE * 4;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:125:AlignedStorage<std::array<float, MAX_FFT_SIZE>> fftInputBuffer_;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:126:AlignedStorage<std::array<float, MAX_FFT_SIZE>> fftOutputBuffer_;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:132:// Overlap-add processing
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:133:RTCircularBuffer<float, MAX_OVERLAP_SIZE> inputRingBuffer_;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:134:RTCircularBuffer<float, MAX_OVERLAP_SIZE> outputRingBuffer_;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:154:mutable std::atomic<float> spectralCentroid_{0.0f};
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:155:mutable std::atomic<uint32_t> maskColumnsProcessed_{0};
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:160:void resetSpectralState() noexcept;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:161:void updateSpectralFeatures() noexcept;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:205:namespace SpectralCoreOps
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:207:// Pure spectral processing functions
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:208:void computeMagnitudeSpectrum(const float* fftData, float* magnitudes, int numBins) noexcept;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:209:void computePhaseSpectrum(const float* fftData, float* phases, int numBins) noexcept;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:210:void applySpectralMask(float* magnitudes, const float* mask, int numBins, float depth) noexcept;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:212:float* fftData, int fftSize) noexcept;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:214:// Spectral analysis functions
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:215:float computeSpectralCentroid(const float* magnitudes, int numBins, float binFreq) noexcept;
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:2:#include <juce_gui_basics/juce_gui_basics.h>
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:3:#include <juce_dsp/juce_dsp.h>
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:5:// Lightweight offline STFT → Image renderer for UI background
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:11:static juce::Colour map(float normFreq, float normMag)
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:14:const float h = juce::jlimit(0.0f, 1.0f, normFreq);
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:15:const float v = juce::jlimit(0.0f, 1.0f, std::pow(normMag, 0.6f)); // perceptual
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:18:if (h < 0.33f)      hue = juce::jmap(h, 0.0f, 0.33f, 0.85f, 0.95f); // purple→magenta
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:19:else if (h < 0.66f) hue = juce::jmap(h, 0.33f, 0.66f, 0.08f, 0.33f); // red/orange→green
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:20:else                hue = juce::jmap(h, 0.66f, 1.0f, 0.50f, 0.16f);  // cyan→yellow
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:21:const float sat = juce::jlimit(0.2f, 0.95f, 0.65f + 0.25f * (1.0f - v));
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:22:return juce::Colour::fromHSV(hue, sat, v, 1.0f);
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:26:// Renders a spectrogram image (width x height) for a mono or stereo buffer (first channel used)
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:27:static juce::Image render(const juce::AudioBuffer<float>& buffer,
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:32:const int fftOrder = 11; // 2048
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:33:const int fftSize  = 1 << fftOrder;
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:34:juce::dsp::FFT fft(fftOrder);
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:35:juce::AudioBuffer<float> mono(1, buffer.getNumSamples());
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:37:const int chs = buffer.getNumChannels();
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:42:mono.setSample(0, i, sum / juce::jmax(1, chs));
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:45:juce::Image img(juce::Image::RGB, width, height, false);
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:46:juce::Graphics g(img);
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:47:g.fillAll(juce::Colours::black);
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:49:std::vector<float> window(fftSize);
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:50:for (int i = 0; i < fftSize; ++i)
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:51:window[i] = 0.5f - 0.5f * std::cos(2.0f * juce::MathConstants<float>::pi * i / (fftSize - 1));
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:53:std::vector<float> fftData(2 * fftSize);
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:54:const int hop = fftSize / 4; // 75% overlap
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:55:const int numFrames = juce::jmax(1, (mono.getNumSamples() - fftSize) / hop);
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:61:const int frame = juce::jlimit(0, numFrames - 1, (int)std::round(t * (numFrames - 1)));
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:64:std::fill(fftData.begin(), fftData.end(), 0.0f);
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:65:for (int i = 0; i < fftSize; ++i)
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:66:fftData[i] = mono.getSample(0, start + i) * window[i];
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:67:// Perform FFT
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:68:fft.performRealOnlyForwardTransform(fftData.data());
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:73:const int bin = juce::jlimit(0, fftSize / 2 - 1, (int)std::round(nf * (fftSize / 2 - 1)));
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:74:const float re = fftData[bin];
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:75:const float im = fftData[bin + fftSize / 2];
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:77:const float db = juce::Decibels::gainToDecibels(mag);
C:\spectralCanvas Pro\Source\Core\SpectrogramRenderer.h:78:const float normMag = juce::jlimit(0.0f, 1.0f, (db + 80.0f) / 80.0f);
C:\spectralCanvas Pro\Source\DSP\KeyFilter.cpp:9:void KeyFilter::prepare(int fftSize, int numBins, double sampleRate) {
C:\spectralCanvas Pro\Source\DSP\KeyFilter.cpp:10:currentFftSize_ = fftSize;
C:\spectralCanvas Pro\Source\DSP\KeyFilter.cpp:18:lutA_->fftSize = fftSize;
C:\spectralCanvas Pro\Source\DSP\KeyFilter.cpp:22:lutB_->fftSize = fftSize;
C:\spectralCanvas Pro\Source\DSP\KeyFilter.cpp:79:const double freq = (dst.sampleRate / dst.fftSize) * k;
C:\spectralCanvas Pro\Source\DSP\KeyFilter.cpp:104:// Allow all pitch classes
C:\spectralCanvas Pro\Source\DSP\KeyFilter.h:19:int fftSize = 0;
C:\spectralCanvas Pro\Source\DSP\KeyFilter.h:35:void prepare(int fftSize, int numBins, double sampleRate);
C:\spectralCanvas Pro\Source\DSP\KeyFilter.h:63:int currentFftSize_ = 0;
C:\spectralCanvas Pro\Source\DSP\MaskTestFeeder.cpp:66:mask = ringBuffer_[currentRead];
C:\spectralCanvas Pro\Source\DSP\MaskTestFeeder.cpp:134:ringBuffer_[currentWrite] = mask;
C:\spectralCanvas Pro\Source\DSP\MaskTestFeeder.h:8:* RT-safe test harness for validating MaskColumn → SpectralEngine → audio output
C:\spectralCanvas Pro\Source\DSP\MaskTestFeeder.h:47:std::array<MaskColumn, RING_CAPACITY> ringBuffer_;
C:\spectralCanvas Pro\Source\DSP\MaskTestFeeder.h:58:size_t numBins_ = 257; // FFT_SIZE/2 + 1
C:\spectralCanvas Pro\Source\DSP\MorphFilter.h:3:#include <juce_dsp/juce_dsp.h>
C:\spectralCanvas Pro\Source\DSP\MorphFilter.h:4:#include <juce_audio_basics/juce_audio_basics.h>
C:\spectralCanvas Pro\Source\DSP\MorphFilter.h:53:for (auto& state : channelStates)
C:\spectralCanvas Pro\Source\DSP\MorphFilter.h:64:void processBlock(juce::AudioBuffer<float>& buffer) noexcept
C:\spectralCanvas Pro\Source\DSP\MorphFilter.h:67:const int numChannels = buffer.getNumChannels();
C:\spectralCanvas Pro\Source\DSP\MorphFilter.h:74:for (int channel = 0; channel < numChannels && channel < 2; ++channel)
C:\spectralCanvas Pro\Source\DSP\MorphFilter.h:76:float* channelData = buffer.getWritePointer(channel);
C:\spectralCanvas Pro\Source\DSP\MorphFilter.h:77:float input = channelData[sample];
C:\spectralCanvas Pro\Source\DSP\MorphFilter.h:86:auto& state = channelStates[channel];
C:\spectralCanvas Pro\Source\DSP\MorphFilter.h:128:int resIndex = juce::jlimit(0, 255, (int)(currentResonance * 25.5f));
C:\spectralCanvas Pro\Source\DSP\MorphFilter.h:137:channelData[sample] = output;
C:\spectralCanvas Pro\Source\DSP\MorphFilter.h:143:void setMorph(float value) noexcept { targetMorph = juce::jlimit(0.0f, 1.0f, value); }
C:\spectralCanvas Pro\Source\DSP\MorphFilter.h:144:void setCutoff(float hz) noexcept { targetCutoff = juce::jlimit(20.0f, 20000.0f, hz); }
C:\spectralCanvas Pro\Source\DSP\MorphFilter.h:145:void setResonance(float q) noexcept { targetResonance = juce::jlimit(0.1f, 10.0f, q); }
C:\spectralCanvas Pro\Source\DSP\MorphFilter.h:146:void setDrive(float db) noexcept { targetDrive = juce::jlimit(0.0f, 24.0f, db); }
C:\spectralCanvas Pro\Source\DSP\MorphFilter.h:157:// Per-channel state
C:\spectralCanvas Pro\Source\DSP\MorphFilter.h:158:std::array<SVFState, 2> channelStates;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:2:#include <juce_audio_formats/juce_audio_formats.h>
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:8:, numSpectralFrames_(0)
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:11:, hannWindow_(RTWindow<FFT_SIZE>::Hann)
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:24:RT_SAFE_LOG("Initializing SampleLoader with sample rate: " + juce::String(sampleRate));
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:28:// Initialize FFT engines (allocation allowed here)
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:29:const int fftOrder = (int)std::log2(FFT_SIZE);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:30:forwardFFT_ = std::make_unique<juce::dsp::FFT>(fftOrder);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:32:// Pre-allocate spectral frame storage
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:33:spectralFrames_ = std::make_unique<SpectralFrameData[]>(MAX_SAMPLE_FRAMES);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:43:numSpectralFrames_.store(0, std::memory_order_release);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:53:bool SampleLoader::loadSampleFile(const juce::File& audioFile)
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:57:juce::Logger::writeToLog("SampleLoader: File does not exist - " + audioFile.getFullPathName());
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:61:juce::Logger::writeToLog("SampleLoader: Loading file - " + audioFile.getFullPathName());
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:64:juce::AudioFormatManager formatManager;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:68:std::unique_ptr<juce::AudioFormatReader> reader(formatManager.createReaderFor(audioFile));
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:71:juce::Logger::writeToLog("SampleLoader: Could not create reader for file");
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:77:const auto numChannels = static_cast<int>(reader->numChannels);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:80:if (numSamples <= 0 || numChannels <= 0)
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:82:juce::Logger::writeToLog("SampleLoader: Invalid sample data");
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:86:juce::AudioBuffer<float> audioBuffer(numChannels, numSamples);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:95:sampleInfo_.numChannels = numChannels;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:102:juce::Logger::writeToLog("SampleLoader: Successfully loaded " + juce::String(numSamples) + " samples");
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:106:bool SampleLoader::loadSampleFromMemory(const float* samples, int numSamples, int numChannels, double sourceSampleRate)
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:108:if (!samples || numSamples <= 0 || numChannels <= 0)
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:110:juce::Logger::writeToLog("SampleLoader: Invalid sample data provided");
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:115:juce::AudioBuffer<float> audioBuffer(numChannels, numSamples);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:116:for (int ch = 0; ch < numChannels; ++ch)
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:127:sampleInfo_.numChannels = numChannels;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:134:juce::Logger::writeToLog("SampleLoader: Successfully loaded from memory");
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:138:void SampleLoader::preprocessSample(const juce::AudioBuffer<float>& audioBuffer, double sourceSampleRate)
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:140:juce::Logger::writeToLog("SampleLoader: Preprocessing sample...");
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:145:// Resample if needed
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:148:resampleIfNeeded(workingBuffer, sourceSampleRate);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:151:// Mix to mono if multi-channel
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:152:if (workingBuffer.getNumChannels() > 1)
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:157:for (int ch = 0; ch < workingBuffer.getNumChannels(); ++ch)
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:161:workingBuffer.setSample(0, sample, sum / workingBuffer.getNumChannels());
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:169:// Perform STFT on the preprocessed audio
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:173:performSTFT(samples, numSamples, 0);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:183:sampleInfo_.numSpectralFrames = numSpectralFrames_.load();
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:186:juce::Logger::writeToLog("SampleLoader: Preprocessing complete - " +
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:187:juce::String(numSpectralFrames_.load()) + " spectral frames generated");
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:190:void SampleLoader::performSTFT(const float* samples, int numSamples, size_t startFrame)
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:192:if (!forwardFFT_)
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:196:static_cast<size_t>((numSamples - FFT_SIZE) / HOP_SIZE + 1));
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:198:// Working buffer for FFT
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:199:std::array<float, FFT_SIZE> fftBuffer;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:200:std::array<float, FFT_SIZE> windowedBuffer;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:204:for (size_t samplePos = 0; samplePos + FFT_SIZE <= static_cast<size_t>(numSamples) && frameCount < maxFrames;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:210:std::memcpy(fftBuffer.data(), samples + samplePos, FFT_SIZE * sizeof(float));
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:211:std::memcpy(windowedBuffer.data(), fftBuffer.data(), FFT_SIZE * sizeof(float));
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:214:hannWindow_.apply(windowedBuffer.data());
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:216:// Perform FFT
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:217:forwardFFT_->performRealOnlyForwardTransform(windowedBuffer.data(), true);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:220:auto& magnitude = spectralFrames_[frameIndex].magnitude.get();
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:221:auto& phase = spectralFrames_[frameIndex].phase.get();
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:238:numSpectralFrames_.store(startFrame + frameCount, std::memory_order_release);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:241:void SampleLoader::resampleIfNeeded(juce::AudioBuffer<float>& buffer, double sourceSampleRate)
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:249:juce::AudioBuffer<float> resampledBuffer(buffer.getNumChannels(), newSize);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:252:for (int ch = 0; ch < buffer.getNumChannels(); ++ch)
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:255:float* output = resampledBuffer.getWritePointer(ch);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:268:buffer = std::move(resampledBuffer);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:271:void SampleLoader::normalizeAudio(juce::AudioBuffer<float>& buffer) noexcept
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:276:for (int ch = 0; ch < buffer.getNumChannels(); ++ch)
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:278:const float channelMax = buffer.getMagnitude(ch, 0, buffer.getNumSamples());
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:279:maxLevel = std::max(maxLevel, channelMax);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:290:bool SampleLoader::getSpectralFrame(size_t frameIndex, float* magnitudeOut, float* phaseOut) const noexcept
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:292:if (!hasSample() || frameIndex >= numSpectralFrames_.load(std::memory_order_acquire))
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:295:const auto& frame = spectralFrames_[frameIndex];
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:302:void SampleLoader::getSpectralFrameInterpolated(double framePosition, float* magnitudeOut, float* phaseOut) const noexcept
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:311:const size_t numFrames = numSpectralFrames_.load(std::memory_order_acquire);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:326:const auto& frameData0 = spectralFrames_[frame0];
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:327:const auto& frameData1 = spectralFrames_[frame1];
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:3:#include <juce_audio_processors/juce_audio_processors.h>
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:4:#include <juce_dsp/juce_dsp.h>
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:12:* Loads audio files and preprocesses them into spectral frames for RT-safe access
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:17:static constexpr size_t FFT_SIZE = 512;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:19:static constexpr size_t NUM_BINS = FFT_SIZE / 2 + 1;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:20:static constexpr size_t MAX_SAMPLE_FRAMES = 8192; // Max spectral frames per sample
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:25:// Non-copyable for RT safety (handled by JUCE macro below)
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:32:bool loadSampleFile(const juce::File& audioFile);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:33:bool loadSampleFromMemory(const float* samples, int numSamples, int numChannels, double sourceSampleRate);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:37:size_t getNumSpectralFrames() const noexcept { return numSpectralFrames_.load(std::memory_order_acquire); }
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:41:// RT-safe spectral frame access (audio thread only)
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:42:bool getSpectralFrame(size_t frameIndex, float* magnitudeOut, float* phaseOut) const noexcept;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:43:void getSpectralFrameInterpolated(double framePosition, float* magnitudeOut, float* phaseOut) const noexcept;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:52:juce::String filename;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:55:int numChannels = 0;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:56:size_t numSpectralFrames = 0;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:63:// Pre-allocated spectral frame storage
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:64:struct SpectralFrameData
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:69:SpectralFrameData() noexcept = default;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:72:// Pre-allocated array of spectral frames
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:73:std::unique_ptr<SpectralFrameData[]> spectralFrames_;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:76:void preprocessSample(const juce::AudioBuffer<float>& audioBuffer, double sourceSampleRate);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:77:void performSTFT(const float* samples, int numSamples, size_t startFrame);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:78:void resampleIfNeeded(juce::AudioBuffer<float>& buffer, double sourceSampleRate);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:79:void normalizeAudio(juce::AudioBuffer<float>& buffer) noexcept;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:81:// FFT processing (allocation allowed during loading)
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:82:std::unique_ptr<juce::dsp::FFT> forwardFFT_;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:83:RTWindow<FFT_SIZE> hannWindow_;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:87:std::atomic<size_t> numSpectralFrames_;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:98:JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(SampleLoader)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:1:#include "SpectralEngine_Fixed.h"
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:9:SpectralEngine::SpectralEngine() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:13:, spectralGain_(1.0f)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:14:, spectralMix_(1.0f)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:17:, spectralCentroid_(0.0f)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:21:fftBuffer_.fill(0.0f);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:22:ifftBuffer_.fill(0.0f);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:31:// Generate Hann window
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:32:for (size_t i = 0; i < FFT_SIZE; ++i)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:34:hannWindow_[i] = 0.5f * (1.0f - std::cos(2.0f * M_PI * i / (FFT_SIZE - 1)));
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:38:SpectralEngine::~SpectralEngine() noexcept = default;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:40:void SpectralEngine::initialize(double sampleRate, int maxBlockSize)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:42:juce::ignoreUnused(maxBlockSize);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:46:// Initialize FFT engines (allocation allowed here)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:47:const int fftOrder = (int)std::log2(FFT_SIZE);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:48:forwardFFT_ = std::make_unique<juce::dsp::FFT>(fftOrder);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:49:inverseFFT_ = std::make_unique<juce::dsp::FFT>(fftOrder);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:59:void SpectralEngine::reset() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:62:fftBuffer_.fill(0.0f);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:63:ifftBuffer_.fill(0.0f);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:84:void SpectralEngine::processBlock(const float* inputBuffer, float* outputBuffer, int numSamples) noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:93:// Simple pass-through for now with basic spectral analysis
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:99:// Store input data for spectral analysis
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:112:// Trigger spectral analysis every HOP_SIZE samples
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:116:performSTFT();
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:117:updateSpectralFeatures();
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:126:void SpectralEngine::performSTFT() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:128:if (!forwardFFT_) return;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:130:// Read FFT_SIZE samples from circular buffer
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:138:if (available < FFT_SIZE) return;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:141:for (size_t i = 0; i < FFT_SIZE; ++i)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:144:windowedBuffer_[i] = inputBuffer_[pos] * hannWindow_[i];
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:150:// Perform forward FFT (in-place)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:151:std::copy(windowedBuffer_.begin(), windowedBuffer_.end(), fftBuffer_.begin());
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:152:forwardFFT_->performRealOnlyForwardTransform(fftBuffer_.data(), true);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:161:fftBuffer_[bin] : fftBuffer_[realIndex];
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:163:0.0f : fftBuffer_[imagIndex];
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:170:void SpectralEngine::updateSpectralFeatures() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:172:// Calculate spectral centroid
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:176:const float binWidth = static_cast<float>(sampleRate_) / FFT_SIZE;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:187:const float centroid = (magnitudeSum > 0.0f) ? weightedSum / magnitudeSum : 0.0f;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:188:spectralCentroid_.store(centroid, std::memory_order_relaxed);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:209:void SpectralEngine::performiFFT() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:214:void SpectralEngine::applySpectralProcessing() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:216:const float gain = spectralGain_.load(std::memory_order_relaxed);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:228:bool SpectralEngine::extractSpectralFrame(SpectralFrame& frame) noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:233:// Copy current spectral data
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:241:frame.spectralCentroid = spectralCentroid_.load(std::memory_order_relaxed);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:3:#include <juce_dsp/juce_dsp.h>
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:4:#include <juce_audio_processors/juce_audio_processors.h>
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:9:class SpectralEngine
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:12:static constexpr size_t FFT_SIZE = 512;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:14:static constexpr size_t NUM_BINS = FFT_SIZE / 2 + 1;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:16:SpectralEngine() noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:17:~SpectralEngine() noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:20:SpectralEngine(const SpectralEngine&) = delete;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:21:SpectralEngine& operator=(const SpectralEngine&) = delete;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:30:// RT-safe spectral data extraction (audio thread only)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:31:bool extractSpectralFrame(SpectralFrame& frame) noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:34:void setSpectralGain(float gain) noexcept { spectralGain_.store(gain, std::memory_order_relaxed); }
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:35:void setSpectralMix(float mix) noexcept { spectralMix_.store(mix, std::memory_order_relaxed); }
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:43:void performSTFT() noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:44:void performiFFT() noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:45:void updateSpectralFeatures() noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:46:void applySpectralProcessing() noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:49:std::array<float, FFT_SIZE> fftBuffer_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:50:std::array<float, FFT_SIZE> ifftBuffer_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:51:std::array<float, FFT_SIZE> windowedBuffer_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:52:std::array<float, FFT_SIZE> overlapBuffer_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:54:// Spectral data (magnitude and phase)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:60:static constexpr size_t BUFFER_SIZE = FFT_SIZE * 4;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:68:// FFT processing
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:69:std::unique_ptr<juce::dsp::FFT> forwardFFT_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:70:std::unique_ptr<juce::dsp::FFT> inverseFFT_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:71:std::array<float, FFT_SIZE> hannWindow_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:79:std::atomic<float> spectralGain_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:80:std::atomic<float> spectralMix_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:86:// Spectral analysis
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:87:std::atomic<float> spectralCentroid_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:1:#include "SpectralEngine.h"
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:5:SpectralEngine::SpectralEngine() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:6:: hannWindow_(RTWindow<FFT_SIZE>::Hann)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:10:, spectralGain_(1.0f)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:11:, spectralMix_(1.0f)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:14:, spectralCentroid_(0.0f)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:17:RT_SAFE_LOG("SpectralEngine constructor called");
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:20:SpectralEngine::~SpectralEngine() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:22:RT_SAFE_LOG("SpectralEngine destructor called");
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:25:void SpectralEngine::initialize(double sampleRate, int maxBlockSize)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:27:RT_SAFE_LOG("Initializing SpectralEngine with sample rate: " + juce::String(sampleRate));
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:31:// Initialize FFT engines (allocation allowed here)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:32:const int fftOrder = (int)std::log2(FFT_SIZE);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:33:forwardFFT_ = std::make_unique<juce::dsp::FFT>(fftOrder);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:34:inverseFFT_ = std::make_unique<juce::dsp::FFT>(fftOrder);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:37:fftBuffer_.get().fill(0.0f);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:38:ifftBuffer_.get().fill(0.0f);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:55:RT_SAFE_LOG("SpectralEngine initialization complete");
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:58:void SpectralEngine::reset() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:60:RT_SAFE_LOG("Resetting SpectralEngine");
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:63:fftBuffer_.get().fill(0.0f);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:64:ifftBuffer_.get().fill(0.0f);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:77:void SpectralEngine::processBlock(const float* inputBuffer, float* outputBuffer, int numSamples) noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:111:if (inputBuffer_.getAvailableForReading() >= HOP_SIZE)  // FIX: Check for HOP_SIZE, not FFT_SIZE
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:113:performSTFT();
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:114:applySpectralProcessing();
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:115:performiFFT();
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:134:void SpectralEngine::performSTFT() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:137:std::memmove(fftBuffer_.get().data(),
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:138:fftBuffer_.get().data() + HOP_SIZE,
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:139:(FFT_SIZE - HOP_SIZE) * sizeof(float));
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:142:inputBuffer_.readBlock(fftBuffer_.get().data() + (FFT_SIZE - HOP_SIZE), HOP_SIZE);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:145:std::memcpy(windowedBuffer_.get().data(), fftBuffer_.get().data(), FFT_SIZE * sizeof(float));
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:146:hannWindow_.apply(windowedBuffer_.get().data());
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:148:// Perform forward FFT (in-place)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:149:forwardFFT_->performRealOnlyForwardTransform(windowedBuffer_.get().data(), true);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:151:// FIX: Extract magnitude and phase with correct JUCE real-only FFT packing
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:177:// Update spectral features
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:178:updateSpectralFeatures();
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:181:void SpectralEngine::updateSpectralFeatures() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:183:// Calculate spectral centroid
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:187:const float binWidth = static_cast<float>(sampleRate_) / FFT_SIZE;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:198:const float centroid = (magnitudeSum > 0.0f) ? weightedSum / magnitudeSum : 0.0f;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:199:spectralCentroid_.store(centroid, std::memory_order_relaxed);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:220:void SpectralEngine::applySpectralProcessing() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:222:const float gain = spectralGain_.load(std::memory_order_relaxed);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:248:const float mix = std::clamp(spectralMix_.load(std::memory_order_relaxed), 0.0f, 1.0f);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:264:phaseAcc[bin] += 2.0f * float(M_PI) * float(HOP_SIZE) * float(bin) / float(FFT_SIZE);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:283:void SpectralEngine::performiFFT() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:285:// FIX: Reconstruct complex spectrum with correct JUCE real-only FFT packing
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:296:ifftBuffer_.get()[0] = real;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:300:ifftBuffer_.get()[1] = real;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:305:ifftBuffer_.get()[idx]     = real;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:306:ifftBuffer_.get()[idx + 1] = imag;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:310:// Perform inverse FFT
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:311:inverseFFT_->performRealOnlyInverseTransform(ifftBuffer_.get().data());
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:314:const float invN = 1.0f / static_cast<float>(FFT_SIZE);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:315:for (size_t i = 0; i < FFT_SIZE; ++i)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:316:ifftBuffer_.get()[i] *= invN;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:318:// Apply window and overlap-add
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:319:hannWindow_.apply(ifftBuffer_.get().data());
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:322:for (size_t i = 0; i < FFT_SIZE; ++i)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:324:overlapBuffer_.get()[i] += ifftBuffer_.get()[i];
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:333:(FFT_SIZE - HOP_SIZE) * sizeof(float));
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:336:std::memset(overlapBuffer_.get().data() + (FFT_SIZE - HOP_SIZE),
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:340:bool SpectralEngine::extractSpectralFrame(SpectralFrame& frame) noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:345:// Copy current spectral data
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:353:frame.spectralCentroid = spectralCentroid_.load(std::memory_order_relaxed);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:358:void SpectralEngine::updateCurrentMask(const MaskColumn* maskColumn) noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:372:void SpectralEngine::updateCurrentMask(const float* maskPtr, int numBins) noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:387:void SpectralEngine::applyMaskColumn(const MaskColumn& maskColumn) noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:416:const float carrierBin = (CARRIER_FREQ / sampleRate) * FFT_SIZE;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:3:#include <juce_dsp/juce_dsp.h>
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:4:#include <juce_audio_processors/juce_audio_processors.h>
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:11:class SpectralEngine
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:17:Resynth = 1, // Sample-based spectral manipulation
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:21:static constexpr size_t FFT_SIZE = 512;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:23:static constexpr size_t NUM_BINS = FFT_SIZE / 2 + 1;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:24:static constexpr size_t OVERLAP_BUFFER_SIZE = FFT_SIZE * 4;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:26:SpectralEngine() noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:27:~SpectralEngine() noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:30:SpectralEngine(const SpectralEngine&) = delete;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:31:SpectralEngine& operator=(const SpectralEngine&) = delete;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:40:// RT-safe spectral data extraction (audio thread only)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:41:bool extractSpectralFrame(SpectralFrame& frame) noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:44:void setSpectralGain(float gain) noexcept { spectralGain_.store(gain, std::memory_order_relaxed); }
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:45:void setSpectralMix(float mix) noexcept { spectralMix_.store(mix, std::memory_order_relaxed); }
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:63:void performSTFT() noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:64:void performiFFT() noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:65:void updateSpectralFeatures() noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:66:void applySpectralProcessing() noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:69:AlignedStorage<std::array<float, FFT_SIZE>> fftBuffer_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:70:AlignedStorage<std::array<float, FFT_SIZE>> ifftBuffer_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:71:AlignedStorage<std::array<float, FFT_SIZE>> windowedBuffer_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:72:AlignedStorage<std::array<float, FFT_SIZE>> overlapBuffer_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:74:// Spectral data (magnitude and phase)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:79:// Input/output circular buffers for overlap-add processing
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:83:// FFT processing
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:84:std::unique_ptr<juce::dsp::FFT> forwardFFT_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:85:std::unique_ptr<juce::dsp::FFT> inverseFFT_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:86:RTWindow<FFT_SIZE> hannWindow_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:100:std::atomic<float> spectralGain_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:101:std::atomic<float> spectralMix_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:108:// Current mask for spectral painting (RT-safe atomic pointer)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:115:// Spectral analysis
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:116:std::atomic<float> spectralCentroid_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:1:#include "SpectralEngineStub.h"
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:7:void SpectralEngineStub::prepare(double sampleRate, int fftSize, int numBins, int channels) {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:9:fftSize_ = fftSize;
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:11:channels_ = channels;
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:19:// Precompute per-bin phase increments (2π * k / fftSize)
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:20:const double twoPiOverFft = juce::MathConstants<double>::twoPi / fftSize;
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:22:binIncr_[k] = static_cast<float>(twoPiOverFft * k);
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:28:void SpectralEngineStub::reset() {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:44:void SpectralEngineStub::setStride(int stride) {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:48:void SpectralEngineStub::popAllMaskColumnsInto(MaskColumnQueue& queue) noexcept {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:99:#if JUCE_DEBUG
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:110:juce::Logger::writeToLog(juce::String::formatted(
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:111:"SpectralEngineStub: gotAny=%s, totalPops=%llu, receivedMag=%.6f, actualMag=%.6f",
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:117:void SpectralEngineStub::process(juce::AudioBuffer<float>& outBuffer, float oscGain) noexcept {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:124:#if JUCE_DEBUG
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:127:juce::Logger::writeToLog(juce::String::formatted(
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:128:"SpectralEngineStub::process: oscGain=%.3f, activeBins=%d",
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:141:#if JUCE_DEBUG
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:148:juce::Logger::writeToLog(juce::String::formatted(
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:149:"SpectralEngineStub: activeBins=%d, maxMag=%.6f, oscGain=%.3f",
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:181:#if JUCE_DEBUG
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:184:juce::Logger::writeToLog(juce::String::formatted(
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:191:#if JUCE_DEBUG
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:194:const int testBin = static_cast<int>((440.0 * fftSize_) / sampleRate_);
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:203:float outputRMS = outBuffer.getNumChannels() > 0 ? outBuffer.getRMSLevel(0, 0, numSamples) : 0.0f;
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:211:juce::Logger::writeToLog(juce::String::formatted(
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:218:int SpectralEngineStub::calculateStride(int activeBinCount) const noexcept {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:225:void SpectralEngineStub::smoothMagnitudes() noexcept {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:240:int SpectralEngineStub::countActiveBins() const noexcept {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:252:void SpectralEngineStub::renderBinAdd(juce::AudioBuffer<float>& outBuffer, int bin, float amplitude) noexcept {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:257:const int numChannels = std::min(outBuffer.getNumChannels(), channels_);
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:265:// Add to all output channels (mono synthesis, centered)
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:266:for (int ch = 0; ch < numChannels; ++ch) {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:272:if (phase > juce::MathConstants<float>::twoPi) {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:273:phase -= juce::MathConstants<float>::twoPi;
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.h:2:#include <juce_audio_processors/juce_audio_processors.h>
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.h:3:#include <juce_dsp/juce_dsp.h>
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.h:9:class SpectralEngineStub {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.h:11:SpectralEngineStub() = default;
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.h:12:~SpectralEngineStub() = default;
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.h:15:void prepare(double sampleRate, int fftSize, int numBins, int channels);
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.h:24:void process(juce::AudioBuffer<float>& outBuffer, float oscGain) noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.h:45:int fftSize_ = 512;
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.h:47:int channels_ = 2;
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.h:57:juce::HeapBlock<float> magnitudes_;     // Current target magnitudes [numBins]
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.h:58:juce::HeapBlock<float> smoothed_;       // Smoothed magnitudes [numBins]
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.h:59:juce::HeapBlock<float> phases_;         // Phase accumulators [numBins]
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.h:60:juce::HeapBlock<float> binIncr_;        // Per-sample phase increment [numBins]
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.h:83:void renderBinAdd(juce::AudioBuffer<float>& outBuffer, int bin, float amplitude) noexcept;
C:\spectralCanvas Pro\Source\DSP\SpscRingBuffer.h:8:class SpscRingBuffer
C:\spectralCanvas Pro\Source\DSP\SpscRingBuffer.h:10:static_assert((Capacity & (Capacity - 1)) == 0, "Capacity must be power of two");
C:\spectralCanvas Pro\Source\DSP\SpscRingBuffer.h:12:SpscRingBuffer() noexcept : head_(0), tail_(0) {}
C:\spectralCanvas Pro\Source\DSP\SynthEngine.h:3:#include <juce_dsp/juce_dsp.h>
C:\spectralCanvas Pro\Source\DSP\SynthEngine.h:4:#include <juce_audio_basics/juce_audio_basics.h>
C:\spectralCanvas Pro\Source\DSP\SynthEngine.h:33:void processBlock(juce::AudioBuffer<float>& buffer,
C:\spectralCanvas Pro\Source\DSP\SynthEngine.h:34:const juce::MidiBuffer& midiMessages) noexcept;
C:\spectralCanvas Pro\Source\DSP\SynthEngine.h:44:// Get current spectral data for visualization
C:\spectralCanvas Pro\Source\DSP\SynthEngine.h:45:void getSpectralMagnitudes(float* magnitudes, size_t numBins) const noexcept;
C:\spectralCanvas Pro\Source\DSP\SynthEngine.h:88:juce::Random random;
C:\spectralCanvas Pro\Source\DSP\SynthEngine.h:99:std::atomic<float> brightness_{0.5f};       // Spectral centroid control
C:\spectralCanvas Pro\Source\DSP\SynthEngine.h:118:void handleMidiMessage(const juce::MidiMessage& message) noexcept;
C:\spectralCanvas Pro\Source\DSP\TripleMailbox.h:6:// Triple‑buffer "mailbox": writer publishes most‑recent snapshot; reader
C:\spectralCanvas Pro\Source\DSP\TripleMailbox.h:9:struct TripleMailbox
C:\spectralCanvas Pro\Source\DSP\TripleMailbox.h:11:TripleMailbox() noexcept : latest_(0), writeIdx_(1) {}
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:4:BottomBar::BottomBar(SpectralCanvasProAudioProcessor& processor, CanvasComponent& canvas)
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:17:playButton = std::make_unique<juce::TextButton>("▶");
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:19:playButton->setColour(juce::TextButton::buttonColourId, juce::Colour(0xff2d2d2d));
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:20:playButton->setColour(juce::TextButton::textColourOnId, getNebulaAccentColor());
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:23:stopButton = std::make_unique<juce::TextButton>("⏹");
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:25:stopButton->setColour(juce::TextButton::buttonColourId, juce::Colour(0xff2d2d2d));
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:28:loopButton = std::make_unique<juce::ToggleButton>("🔄");
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:33:speedSlider = std::make_unique<juce::Slider>(juce::Slider::LinearHorizontal, juce::Slider::TextBoxRight);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:36:speedSlider->setTextBoxStyle(juce::Slider::TextBoxRight, false, 40, 20);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:40:speedLabel.setText("Speed", juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:41:speedLabel.setColour(juce::Label::textColourId, juce::Colours::white);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:42:speedLabel.setFont(juce::FontOptions().withPointHeight(12.0f));
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:45:gainSlider = std::make_unique<juce::Slider>(juce::Slider::LinearHorizontal, juce::Slider::TextBoxRight);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:48:gainSlider->setTextBoxStyle(juce::Slider::TextBoxRight, false, 40, 20);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:52:gainLabel.setText("Gain", juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:53:gainLabel.setColour(juce::Label::textColourId, juce::Colours::white);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:54:gainLabel.setFont(juce::FontOptions().withPointHeight(12.0f));
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:58:latencyLabel.setText("Latency: 17 ms", juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:59:latencyLabel.setColour(juce::Label::textColourId, juce::Colours::lightgrey);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:60:latencyLabel.setFont(juce::FontOptions().withPointHeight(11.0f));
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:63:fpsLabel.setText("60 fps", juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:64:fpsLabel.setColour(juce::Label::textColourId, juce::Colours::lightgrey);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:65:fpsLabel.setFont(juce::FontOptions().withPointHeight(11.0f));
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:68:cpuLabel.setText("CPU: 12%", juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:69:cpuLabel.setColour(juce::Label::textColourId, juce::Colours::lightgrey);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:70:cpuLabel.setFont(juce::FontOptions().withPointHeight(11.0f));
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:73:fftSizeLabel.setText("FFT Size: 4096", juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:74:fftSizeLabel.setColour(juce::Label::textColourId, juce::Colours::lightgrey);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:75:fftSizeLabel.setFont(juce::FontOptions().withPointHeight(11.0f));
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:76:addAndMakeVisible(fftSizeLabel);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:79:serviceHealthLabel.setText("Service Health", juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:80:serviceHealthLabel.setColour(juce::Label::textColourId, juce::Colours::white);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:81:serviceHealthLabel.setFont(juce::FontOptions().withPointHeight(10.0f));
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:88:void BottomBar::paint(juce::Graphics& g)
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:93:g.setColour(juce::Colour(0xffc0c0c0)); // Win95 button face color
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:97:g.setColour(juce::Colour(0xff808080)); // Shadow on top/left
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:101:g.setColour(juce::Colour(0xff404040)); // Dark shadow
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:105:g.setColour(juce::Colours::white); // Highlight on bottom/right
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:116:g.setColour(juce::Colour(0xfff0f0f0));
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:120:g.setColour(juce::Colour(0xff808080));
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:122:g.setColour(juce::Colour(0xff404040));
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:126:g.setColour(juce::Colours::black);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:127:g.setFont(juce::FontOptions().withPointHeight(10.0f));
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:128:g.drawText("Latency: 5.2ms", panelX + 8, panelY + 6, 80, 14, juce::Justification::centredLeft);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:129:g.drawText("CPU: 12.4%", panelX + 8, panelY + 20, 80, 14, juce::Justification::centredLeft);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:130:g.drawText("GPU: Ready", panelX + 90, panelY + 6, 70, 14, juce::Justification::centredLeft);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:131:g.drawText("MEM: 45MB", panelX + 90, panelY + 20, 70, 14, juce::Justification::centredLeft);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:171:fftSizeLabel.setBounds(metricsX + metricsSpacing, y + 4, 80, labelHeight);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:177:void BottomBar::buttonClicked(juce::Button* button)
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:183:playButton->setColour(juce::TextButton::textColourOnId,
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:184:isPlaying ? juce::Colours::orange : getNebulaAccentColor());
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:187:juce::Logger::writeToLog(isPlaying ? "Starting playback" : "Stopping playback");
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:193:playButton->setColour(juce::TextButton::textColourOnId, getNebulaAccentColor());
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:196:juce::Logger::writeToLog("Stop pressed");
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:202:juce::Logger::writeToLog(isLooping ? "Loop enabled" : "Loop disabled");
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:206:void BottomBar::sliderValueChanged(juce::Slider* slider)
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:220:juce::Logger::writeToLog("Gain: " + juce::String(gainDb, 1) + " dB");
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:230:fpsLabel.setText(juce::String((int)fps) + " fps", juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:231:cpuLabel.setText("CPU: " + juce::String((int)cpuPercent) + "%", juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:232:latencyLabel.setText("Latency: " + juce::String(latencyMs, 0) + " ms", juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:235:void BottomBar::updateFFTSize(int fftSize)
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:237:currentFFTSize = fftSize;
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:238:fftSizeLabel.setText("FFT Size: " + juce::String(fftSize), juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:254:void BottomBar::drawHealthIndicator(juce::Graphics& g, juce::Rectangle<int> area, bool isHealthy)
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:3:#include <juce_gui_basics/juce_gui_basics.h>
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:4:#include "../SpectralCanvasProAudioProcessor.h"
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:12:class BottomBar : public juce::Component,
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:13:public juce::Button::Listener,
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:14:public juce::Slider::Listener
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:17:BottomBar(SpectralCanvasProAudioProcessor& processor, CanvasComponent& canvas);
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:20:void paint(juce::Graphics& g) override;
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:24:void buttonClicked(juce::Button* button) override;
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:25:void sliderValueChanged(juce::Slider* slider) override;
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:29:void updateFFTSize(int fftSize);
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:36:SpectralCanvasProAudioProcessor& audioProcessor;
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:40:std::unique_ptr<juce::TextButton> playButton;
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:41:std::unique_ptr<juce::TextButton> stopButton;
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:42:std::unique_ptr<juce::ToggleButton> loopButton;
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:45:std::unique_ptr<juce::Slider> speedSlider;         // 0.25x - 4x resynth speed
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:46:std::unique_ptr<juce::Slider> gainSlider;          // -24 to +24 dB
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:47:juce::Label speedLabel;
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:48:juce::Label gainLabel;
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:51:juce::Label latencyLabel;      // "Latency: 17 ms"
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:52:juce::Label fpsLabel;          // "60 fps"
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:53:juce::Label cpuLabel;          // "CPU: 12%"
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:54:juce::Label fftSizeLabel;      // "FFT Size: 4096"
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:57:juce::Label serviceHealthLabel; // "Service Health"
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:58:juce::Component audioHealthIndicator;
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:59:juce::Component gpuHealthIndicator;
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:67:int currentFFTSize = 512;
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:80:void drawHealthIndicator(juce::Graphics& g, juce::Rectangle<int> area, bool isHealthy);
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:81:juce::Colour getNebulaAccentColor() const { return juce::Colour(0xff00bcd4); } // Cyan
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:82:juce::Colour getHealthColor(bool healthy) const
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:84:return healthy ? juce::Colours::lightgreen : juce::Colours::orangered;
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:87:JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(BottomBar)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:4:#include "../Viz/backends/D3D11Renderer.h"
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:6:CanvasComponent::CanvasComponent(SpectralCanvasProAudioProcessor& processor)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:10:juce::Logger::writeToLog("CanvasComponent constructor started");
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:22:juce::Logger::writeToLog("CanvasComponent constructor completed");
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:36:void CanvasComponent::paint(juce::Graphics& g)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:39:g.fillAll(juce::Colour(0xff0a0a0f)); // Dark background
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:48:g.setColour(juce::Colours::white.withAlpha(0.8f));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:56:g.setColour(juce::Colours::lime);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:57:g.setFont(juce::FontOptions(12.0f));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:60:g.drawText("Phase 2-3 Minimal UI Active", 8, yPos, 300, 14, juce::Justification::left);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:64:g.drawText(juce::String::formatted("Test Mode: %s", testActive ? "ACTIVE" : "OFF"),
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:65:8, yPos, 300, 14, juce::Justification::left);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:69:void CanvasComponent::paintSoftwareFallback(juce::Graphics& g)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:76:juce::ColourGradient gradient(
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:77:juce::Colour(0xff4a148c),  // Deep purple
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:79:juce::Colour(0xff00bcd4),  // Cyan
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:83:gradient.addColour(0.3, juce::Colour(0xff7b1fa2)); // Purple mid
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:84:gradient.addColour(0.7, juce::Colour(0xff26c6da)); // Light cyan
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:89:// Add animated spectral bars (if we have spectral data)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:90:auto& spectralQueue = audioProcessor.getSpectralDataQueue();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:91:if (spectralQueue.hasDataAvailable())
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:93:// Process latest spectral frame
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:94:while (auto frame = spectralQueue.pop())
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:96:// Draw spectral bins as nebula texture
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:97:const int numBins = SpectralFrame::NUM_BINS;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:107:float brightness = juce::jlimit(0.0f, 1.0f, (dbMagnitude + 80.0f) / 80.0f);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:110:float hue = juce::jlimit(0.0f, 1.0f, 0.76f - frequency * 0.24f); // 0.76=purple, 0.52=cyan
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:111:juce::Colour binColor = juce::Colour::fromHSV(hue, 0.9f, brightness * 0.8f, brightness * 0.6f);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:126:g.setColour(juce::Colours::white.withAlpha(0.4f));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:133:g.setColour(juce::Colours::white.withAlpha(twinkle * 0.6f));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:143:juce::Path strokePath;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:152:g.strokePath(strokePath, juce::PathStrokeType(stroke.brushSize * 0.5f));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:155:g.strokePath(strokePath, juce::PathStrokeType(2.0f));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:161:juce::Path activePath;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:168:g.setColour(juce::Colours::white.withAlpha(0.9f));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:169:g.strokePath(activePath, juce::PathStrokeType(3.0f));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:179:void CanvasComponent::mouseDown(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:194:currentStroke.startTime = juce::Time::getMillisecondCounter();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:199:point.spectralPos = screenToSpectral(e.position);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:211:void CanvasComponent::mouseDrag(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:218:point.spectralPos = screenToSpectral(e.position);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:220:point.timestamp = (juce::Time::getMillisecondCounter() - currentStroke.startTime) / 1000.0f;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:224:// METASYNTH-STYLE: Generate immediate spectral feedback
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:241:void CanvasComponent::mouseUp(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:243:juce::ignoreUnused(e);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:267:void CanvasComponent::mouseMove(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:273:void CanvasComponent::mouseWheelMove(const juce::MouseEvent& e, const juce::MouseWheelDetails& wheel)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:275:juce::ignoreUnused(e);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:279:currentBrushSize = juce::jlimit(1.0f, 128.0f, currentBrushSize + delta);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:290:bool CanvasComponent::isInterestedInFileDrag(const juce::StringArray& files)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:305:void CanvasComponent::fileDragEnter(const juce::StringArray& files, int x, int y)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:307:juce::ignoreUnused(files, x, y);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:312:void CanvasComponent::fileDragExit(const juce::StringArray& files)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:314:juce::ignoreUnused(files);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:319:void CanvasComponent::filesDropped(const juce::StringArray& files, int x, int y)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:321:juce::ignoreUnused(x, y);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:327:juce::File audioFile(files[0]);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:331:juce::Logger::writeToLog("Loading sample: " + audioFile.getFullPathName());
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:346:processSpectralData();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:362:juce::Point<float> CanvasComponent::screenToSpectral(juce::Point<float> screenPos) const
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:375:return juce::Point<float>(juce::jlimit(0.0f, 1.0f, u),
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:376:juce::jlimit(0.0f, 1.0f, v));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:379:juce::Point<float> CanvasComponent::spectralToScreen(juce::Point<float> spectralPos) const
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:388:float x = spectralPos.x * canvasWidth;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:389:float y = topMargin + (1.0f - spectralPos.y) * usableHeight;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:391:return juce::Point<float>(x, y);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:398:juce::Logger::writeToLog("Paint stroke: " + juce::String(stroke.points.size()) +
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:399:" points, type " + juce::String(stroke.brushType));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:402:void CanvasComponent::processSpectralData()
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:404:// Process any pending spectral frames from audio thread
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:405:auto& spectralQueue = audioProcessor.getSpectralDataQueue();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:406:while (auto frame = spectralQueue.pop())
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:410:gpuRenderer->updateSpectralTexture(*frame);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:435:void CanvasComponent::drawGridOverlay(juce::Graphics& g)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:445:g.setColour(juce::Colours::white.withAlpha(0.15f));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:465:g.setColour(juce::Colours::white.withAlpha(alpha));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:477:g.setColour(juce::Colours::white.withAlpha(alpha));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:482:void CanvasComponent::drawBrushCursor(juce::Graphics& g)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:489:g.setColour(juce::Colours::white.withAlpha(0.6f));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:493:g.setColour(juce::Colours::white.withAlpha(0.8f));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:505:juce::Colour CanvasComponent::getNebulaAccentColor() const
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:507:return juce::Colour(0xff00bcd4); // Cyan from mockups
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:512:// MetaSynth-style: Convert paint stroke directly to spectral mask
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:513:// spectralPos.y = frequency (0-1), spectralPos.x = time position
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:516:maskColumn.numBins = 257; // For 512-point FFT (NUM_BINS = 257)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:527:const float frequencyRatio = juce::jlimit(0.0f, 1.0f, point.spectralPos.y);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:533:for (int bin = juce::jmax(0, centerBin - brushRadius);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:534:bin <= juce::jmin(static_cast<int>(maskColumn.numBins - 1), centerBin + brushRadius);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:538:const float falloff = juce::jmax(0.0f, 1.0f - (distance / brushRadius));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:542:case 0: // Paint - Add spectral energy
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:543:maskColumn.values[bin] = juce::jlimit(0.0f, 3.0f,
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:551:case 2: // Erase - Remove spectral energy
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:552:maskColumn.values[bin] = juce::jmax(0.0f,
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:4:CanvasComponent::CanvasComponent(SpectralCanvasProAudioProcessor& processor)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:17:void CanvasComponent::paint(juce::Graphics& g)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:19:g.fillAll(juce::Colours::black);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:25:g.setColour(juce::Colours::white.withAlpha(0.8f));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:33:g.setColour(juce::Colours::lime);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:34:g.setFont(juce::FontOptions(12.0f));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:35:g.drawText("Phase 2-3 Minimal UI Active", 8, 18, 300, 14, juce::Justification::left);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:38:g.drawText(juce::String::formatted("Test Mode: %s", testActive ? "ACTIVE" : "OFF"),
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:39:8, 32, 300, 14, juce::Justification::left);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:48:void CanvasComponent::mouseDown(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:65:currentStroke.startTime = juce::Time::getMillisecondCounter();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:70:point.spectralPos = screenToSpectral(e.position);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:80:void CanvasComponent::mouseDrag(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:89:point.spectralPos = screenToSpectral(e.position);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:91:point.timestamp = (juce::Time::getMillisecondCounter() - currentStroke.startTime) / 1000.0f;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:104:void CanvasComponent::mouseUp(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:106:juce::ignoreUnused(e);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:126:void CanvasComponent::mouseMove(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:132:void CanvasComponent::mouseWheelMove(const juce::MouseEvent& e, const juce::MouseWheelDetails& wheel)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:134:juce::ignoreUnused(e);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:137:currentBrushSize = juce::jlimit(1.0f, 128.0f, currentBrushSize + delta);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:147:bool CanvasComponent::isInterestedInFileDrag(const juce::StringArray& files)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:157:void CanvasComponent::fileDragEnter(const juce::StringArray&, int, int)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:163:void CanvasComponent::fileDragExit(const juce::StringArray&)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:169:void CanvasComponent::filesDropped(const juce::StringArray& files, int, int)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:174:juce::Logger::writeToLog("Loading: " + files[0]);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:194:juce::Point<float> CanvasComponent::screenToSpectral(juce::Point<float> screenPos) const
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:202:return juce::Point<float>(juce::jlimit(0.0f, 1.0f, u),
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:203:juce::jlimit(0.0f, 1.0f, v));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:206:juce::Point<float> CanvasComponent::spectralToScreen(juce::Point<float> spectralPos) const
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:211:float x = spectralPos.x * canvasWidth;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:212:float y = (1.0f - spectralPos.y) * canvasHeight;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:214:return juce::Point<float>(x, y);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:7:constexpr int kFftSize = 512;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:8:constexpr int kNumBins = kFftSize / 2 + 1; // 257
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:11:CanvasComponent::CanvasComponent(SpectralCanvasProAudioProcessor& processor)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:31:void CanvasComponent::paint(juce::Graphics& g)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:33:g.fillAll(juce::Colours::black);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:39:g.setColour(juce::Colours::white.withAlpha(0.8f));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:65:juce::String pathStr;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:67:case SpectralCanvasProAudioProcessor::AudioPath::TestFeeder:
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:70:case SpectralCanvasProAudioProcessor::AudioPath::Phase4Synth:
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:74:pathStr += " [" + juce::String(activeBins) + "/" + juce::String(totalBins) + " bins]";
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:83:pathStr += juce::String::formatted("\nQueue: %llu pushes | %llu pops | %llu drops", pushes, pops, drops);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:84:pathStr += juce::String::formatted("\nMaxMag: %.4f | Phase4 Blocks: %llu", maxMag, phase4Blocks);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:87:// Add debug tap for SPSC integrity diagnosis
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:97:pathStr += juce::String::formatted("\nTap: %llu/%llu/%llu (push/fail/pop)", tapPushes, tapPushFails, tapPops);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:98:pathStr += juce::String::formatted("\nSeq: %llu->%llu", seqPushed, seqPopped);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:108:case SpectralCanvasProAudioProcessor::AudioPath::Silent:
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:117:juce::Rectangle<int> panel(8, 8, 520, 120);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:118:g.setColour(juce::Colours::black.withAlpha(0.6f));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:122:g.setFont(juce::FontOptions().withPointHeight(14.0f));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:128:g.setColour(juce::Colours::yellow);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:129:g.drawText(pathStr, x, y, panel.getWidth()-20, lh, juce::Justification::left); y += lh;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:131:g.setColour(metrics.medianLatencyMs <= 5.0f ? juce::Colours::lime : juce::Colours::orange);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:132:g.drawText("Latency: " + juce::String(metrics.medianLatencyMs, 1) + "ms / "
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:133:+ juce::String(metrics.p95LatencyMs, 1) + "ms (med/p95)",
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:134:x, y, panel.getWidth()-20, lh, juce::Justification::left); y += lh;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:136:g.setColour(juce::Colours::lightgrey);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:137:g.drawText("SR: " + juce::String(sr / 1000.0f, 1) + "kHz | Block: "
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:138:+ juce::String(bs) + " samples",
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:139:x, y, panel.getWidth()-20, lh, juce::Justification::left); y += lh;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:141:g.setColour(metrics.dropCount == 0 ? juce::Colours::lime : juce::Colours::red);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:142:g.drawText("Queue: " + juce::String((int)metrics.queueDepth) + "/8 | Drops: "
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:143:+ juce::String((int)metrics.dropCount) + " | Local Drops: " + juce::String(queueDrops),
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:144:x, y, panel.getWidth()-20, lh, juce::Justification::left); y += lh;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:146:g.setColour(currentFPS >= 58.0f ? juce::Colours::lime : juce::Colours::yellow);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:147:g.drawText("FPS: " + juce::String(currentFPS, 1)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:148:+ " | Processed Samples: " + juce::String((long long)metrics.processedSamples)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:149:+ " | XRuns: " + juce::String((int)metrics.xrunCount),
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:150:x, y, panel.getWidth()-20, lh, juce::Justification::left);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:153:juce::ignoreUnused(wrote);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:162:void CanvasComponent::mouseDown(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:182:currentStroke.startTime = juce::Time::getMillisecondCounter();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:187:point.spectralPos = screenToSpectral(e.position);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:197:void CanvasComponent::mouseDrag(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:209:point.spectralPos = screenToSpectral(e.position);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:211:point.timestamp = (juce::Time::getMillisecondCounter() - currentStroke.startTime) / 1000.0f;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:224:void CanvasComponent::mouseUp(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:226:juce::ignoreUnused(e);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:246:void CanvasComponent::mouseMove(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:252:void CanvasComponent::mouseWheelMove(const juce::MouseEvent& e, const juce::MouseWheelDetails& wheel)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:254:juce::ignoreUnused(e);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:257:currentBrushSize = juce::jlimit(1.0f, 128.0f, currentBrushSize + delta);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:267:bool CanvasComponent::isInterestedInFileDrag(const juce::StringArray& files)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:277:void CanvasComponent::fileDragEnter(const juce::StringArray&, int, int)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:283:void CanvasComponent::fileDragExit(const juce::StringArray&)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:289:void CanvasComponent::filesDropped(const juce::StringArray& files, int, int)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:294:juce::Logger::writeToLog("Loading: " + files[0]);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:303:if (audioProcessor.getCurrentPath() == SpectralCanvasProAudioProcessor::AudioPath::Phase4Synth && accumulator_.hasData) {
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:335:if (audioProcessor.getCurrentPath() == SpectralCanvasProAudioProcessor::AudioPath::Phase4Synth) {
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:359:juce::Point<float> CanvasComponent::screenToSpectral(juce::Point<float> screenPos) const
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:367:return juce::Point<float>(juce::jlimit(0.0f, 1.0f, u),
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:368:juce::jlimit(0.0f, 1.0f, v));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:371:juce::Point<float> CanvasComponent::spectralToScreen(juce::Point<float> spectralPos) const
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:376:float x = spectralPos.x * canvasWidth;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:377:float y = (1.0f - spectralPos.y) * canvasHeight;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:379:return juce::Point<float>(x, y);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:392:void CanvasComponent::createAndSendMaskColumn(juce::Point<float> mousePos)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:411:mask.numBins = 257; // Standard FFT size for validation
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:414:// Convert mouse position to spectral position
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:415:auto spectralPos = screenToSpectral(mousePos);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:420:size_t centerBin = static_cast<size_t>(spectralPos.x * (mask.numBins - 1));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:421:float amplitude = spectralPos.y * currentBrushStrength;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:449:inline int CanvasComponent::uiToBinLog(float yNorm, double sampleRate, int fftSize) noexcept
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:453:juce::ignoreUnused(sampleRate); // avoid MSVC C4100 warning
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:454:const int numBins = fftSize / 2 + 1;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:458:void CanvasComponent::createAndSendMaskColumnPhase4(juce::Point<float> mousePos)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:461:juce::Logger::writeToLog("*** PHASE4 PAINT CALLED! ***");
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:466:juce::Logger::writeToLog("PHASE4 Paint Call #" + juce::String(paintCallCounter));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:468:// Convert mouse position to spectral coordinates
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:469:const auto spectralPos = screenToSpectral(mousePos);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:470:const float yNorm = spectralPos.y;  // Already normalized by screenToSpectral
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:473:const int numBins = 257;  // Fixed for 512 FFT
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:475:const int fftSize = 512;  // From current system
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:478:juce::ignoreUnused(sampleRate, fftSize);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:526:juce::Logger::writeToLog("PHASE4: testMask pushed with magnitude 0.5 in bins 100-110");
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:545:juce::Logger::writeToLog("PAINT: getCurrentPath()=" + juce::String(static_cast<int>(audioProcessor.getCurrentPath())));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:550:if (audioProcessor.getCurrentPath() != SpectralCanvasProAudioProcessor::AudioPath::Phase4Synth)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:559:const float yNorm = juce::jlimit(0.0f, 1.0f, (y - bounds.getY()) / bounds.getHeight());
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:560:const int k = juce::jlimit(1, kNumBins - 2,
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:564:auto add = [&](int kk, float v) { vals[kk] = juce::jmax(vals[kk], v); };
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:572:col.timestampSamples = juce::Time::getMillisecondCounterHiRes() * 0.001;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:574:col.uiTimestampMicros = static_cast<uint64_t>(juce::Time::getHighResolutionTicks());
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:591:juce::Logger::writeToLog("*** DIRECT PAINT SUCCESS: bin=" + juce::String(k) + " mag=0.60 (call #" + juce::String(paintCallCount) + ") ***");
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:592:juce::Logger::writeToLog("[UI] MaskQueue addr=" + juce::String::toHexString(reinterpret_cast<uintptr_t>(&q)) + " sizeof(MaskColumn)=" + juce::String(sizeof(MaskColumn)));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:596:bool CanvasComponent::keyPressed(const juce::KeyPress& key)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:600:juce::Logger::writeToLog("*** 'I' KEY PRESSED - INJECTING TEST MASKCOLUMN ***");
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:602:if (audioProcessor.getCurrentPath() == SpectralCanvasProAudioProcessor::AudioPath::Phase4Synth) {
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:606:testCol.timestampSamples = juce::Time::getMillisecondCounterHiRes() * 0.001;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:608:testCol.uiTimestampMicros = juce::Time::getHighResolutionTicksPerSecond();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:615:// Calculate 440Hz bin (k ≈ 440 * fftSize / sampleRate)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:617:const int fftSize = 512;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:618:const int k440 = juce::jlimit(1, 256, static_cast<int>(std::round(440.0 * fftSize / sr)));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:625:juce::Logger::writeToLog("Injecting test column: bin " + juce::String(k440) + " = 0.6, sr=" + juce::String(sr));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:629:juce::Logger::writeToLog("Injection result: " + juce::String(success ? "SUCCESS" : "FAILED"));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:631:juce::Logger::writeToLog("Cannot inject - not in Phase4 mode");
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:636:return Component::keyPressed(key);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:3:#include <juce_gui_basics/juce_gui_basics.h>
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:4:#include "../SpectralCanvasProAudioProcessor.h"
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:15:* - Simple spectral visualization and paint strokes
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:17:* - <5ms paint-to-audio latency via SPSC queues
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:19:class CanvasComponent : public juce::Component,
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:20:public juce::Timer,
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:21:public juce::FileDragAndDropTarget
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:24:CanvasComponent(SpectralCanvasProAudioProcessor& processor);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:28:void paint(juce::Graphics& g) override;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:34:void mouseDown(const juce::MouseEvent& e) override;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:35:void mouseDrag(const juce::MouseEvent& e) override;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:36:void mouseUp(const juce::MouseEvent& e) override;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:37:void mouseMove(const juce::MouseEvent& e) override;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:38:void mouseWheelMove(const juce::MouseEvent& e, const juce::MouseWheelDetails& wheel) override;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:41:bool keyPressed(const juce::KeyPress& key) override;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:44:bool isInterestedInFileDrag(const juce::StringArray& files) override;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:45:void fileDragEnter(const juce::StringArray& files, int x, int y) override;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:46:void fileDragExit(const juce::StringArray& files) override;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:47:void filesDropped(const juce::StringArray& files, int x, int y) override;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:62:SpectralCanvasProAudioProcessor& audioProcessor;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:74:juce::Point<float> position;    // Screen coordinates
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:75:juce::Point<float> spectralPos; // U,V in spectral space (0-1)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:84:juce::uint32 startTime;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:94:juce::Point<float> lastMousePos;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:110:void paintMinimalBackground(juce::Graphics& g);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:111:void paintDebugOverlay(juce::Graphics& g);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:112:void drawSimpleBrushCursor(juce::Graphics& g);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:113:juce::Point<float> screenToSpectral(juce::Point<float> screenPos) const;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:114:juce::Point<float> spectralToScreen(juce::Point<float> spectralPos) const;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:116:void processSpectralData();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:121:void createAndSendMaskColumn(juce::Point<float> mousePos);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:127:static inline int uiToBinLog(float yNorm, double sampleRate, int fftSize) noexcept;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:128:void createAndSendMaskColumnPhase4(juce::Point<float> mousePos);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:153:JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(CanvasComponent)
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:3:MinimalBottomStrip::MinimalBottomStrip(juce::AudioProcessorValueTreeState& apvts)
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:6:// Colormap Selector (Phase 3)
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:7:colormapSelector.addItem("Grey", 1);
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:8:colormapSelector.addItem("Viridis", 2);
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:9:colormapSelector.addItem("Magma", 3);
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:10:colormapSelector.setSelectedId(3); // Default to Magma
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:11:setupControl(colormapSelector, colormapLabel, "Colormap");
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:14:gammaSlider.setSliderStyle(juce::Slider::LinearHorizontal);
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:15:gammaSlider.setTextBoxStyle(juce::Slider::TextBoxLeft, false, 50, 20);
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:21:gainSlider.setSliderStyle(juce::Slider::LinearHorizontal);
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:22:gainSlider.setTextBoxStyle(juce::Slider::TextBoxLeft, false, 50, 20);
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:29:freezeToggle.setColour(juce::ToggleButton::textColourId, juce::Colours::white);
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:33:colormapAttachment = std::make_unique<juce::ComboBoxParameterAttachment>(
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:34:*apvts.getParameter(Params::ParameterIDs::colormapType), colormapSelector);
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:36:gammaAttachment = std::make_unique<juce::SliderParameterAttachment>(
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:39:gainAttachment = std::make_unique<juce::SliderParameterAttachment>(
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:42:freezeAttachment = std::make_unique<juce::ButtonParameterAttachment>(
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:46:void MinimalBottomStrip::paint(juce::Graphics& g)
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:49:g.fillAll(juce::Colour(0xff1a1a1a));
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:52:g.setColour(juce::Colour(0xff404040));
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:61:// Layout controls horizontally: Colormap | Gamma | Gain | Freeze
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:62:auto colormapArea = bounds.removeFromLeft(controlWidth);
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:68:colormapLabel.setBounds(colormapArea.removeFromTop(16));
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:69:colormapSelector.setBounds(colormapArea.reduced(4));
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:81:void MinimalBottomStrip::setupControl(juce::Component& control, juce::Label& label, const juce::String& text)
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:85:label.setText(text, juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:86:label.setFont(juce::FontOptions().withPointHeight(10.0f));
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:87:label.setColour(juce::Label::textColourId, juce::Colour(0xffcccccc));
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.cpp:88:label.setJustificationType(juce::Justification::centredLeft);
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.h:3:#include <juce_gui_basics/juce_gui_basics.h>
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.h:10:* - Colormap selector (Grey/Viridis/Magma)
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.h:15:class MinimalBottomStrip : public juce::Component
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.h:18:MinimalBottomStrip(juce::AudioProcessorValueTreeState& apvts);
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.h:21:void paint(juce::Graphics& g) override;
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.h:25:juce::AudioProcessorValueTreeState& apvts;
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.h:28:juce::ComboBox colormapSelector;
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.h:29:juce::Slider gammaSlider;
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.h:30:juce::Slider gainSlider;
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.h:31:juce::ToggleButton freezeToggle;
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.h:34:juce::Label colormapLabel;
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.h:35:juce::Label gammaLabel;
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.h:36:juce::Label gainLabel;
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.h:37:juce::Label freezeLabel;
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.h:40:std::unique_ptr<juce::ComboBoxParameterAttachment> colormapAttachment;
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.h:41:std::unique_ptr<juce::SliderParameterAttachment> gammaAttachment;
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.h:42:std::unique_ptr<juce::SliderParameterAttachment> gainAttachment;
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.h:43:std::unique_ptr<juce::ButtonParameterAttachment> freezeAttachment;
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.h:45:void setupControl(juce::Component& control, juce::Label& label, const juce::String& text);
C:\spectralCanvas Pro\Source\GUI\MinimalBottomStrip.h:47:JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(MinimalBottomStrip)
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.cpp:3:MinimalTopStrip::MinimalTopStrip(juce::AudioProcessorValueTreeState& apvts)
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.cpp:8:testToggleButton.setColour(juce::ToggleButton::textColourId, juce::Colours::white);
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.cpp:16:maskDepthSlider.setSliderStyle(juce::Slider::LinearHorizontal);
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.cpp:17:maskDepthSlider.setTextBoxStyle(juce::Slider::TextBoxLeft, false, 50, 20);
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.cpp:23:brushStrengthSlider.setSliderStyle(juce::Slider::LinearHorizontal);
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.cpp:24:brushStrengthSlider.setTextBoxStyle(juce::Slider::TextBoxLeft, false, 50, 20);
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.cpp:31:debugToggleButton.setColour(juce::ToggleButton::textColourId, juce::Colours::white);
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.cpp:35:testToggleAttachment = std::make_unique<juce::ButtonParameterAttachment>(
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.cpp:38:maskDepthAttachment = std::make_unique<juce::SliderParameterAttachment>(
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.cpp:41:brushStrengthAttachment = std::make_unique<juce::SliderParameterAttachment>(
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.cpp:44:debugToggleAttachment = std::make_unique<juce::ButtonParameterAttachment>(
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.cpp:48:void MinimalTopStrip::paint(juce::Graphics& g)
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.cpp:51:g.fillAll(juce::Colour(0xff1a1a1a));
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.cpp:54:g.setColour(juce::Colour(0xff404040));
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.cpp:83:void MinimalTopStrip::setupControl(juce::Component& control, juce::Label& label, const juce::String& text)
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.cpp:87:label.setText(text, juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.cpp:88:label.setFont(juce::FontOptions().withPointHeight(10.0f));
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.cpp:89:label.setColour(juce::Label::textColourId, juce::Colour(0xffcccccc));
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.cpp:90:label.setJustificationType(juce::Justification::centredLeft);
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.h:3:#include <juce_gui_basics/juce_gui_basics.h>
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.h:11:* - Standard JUCE components only
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.h:15:class MinimalTopStrip : public juce::Component
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.h:18:MinimalTopStrip(juce::AudioProcessorValueTreeState& apvts);
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.h:21:void paint(juce::Graphics& g) override;
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.h:25:juce::AudioProcessorValueTreeState& apvts;
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.h:28:juce::ToggleButton testToggleButton;
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.h:29:juce::Slider maskDepthSlider;
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.h:30:juce::Slider brushStrengthSlider;
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.h:31:juce::ToggleButton debugToggleButton;
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.h:34:juce::Label testLabel;
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.h:35:juce::Label maskDepthLabel;
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.h:36:juce::Label brushStrengthLabel;
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.h:37:juce::Label debugLabel;
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.h:40:std::unique_ptr<juce::ButtonParameterAttachment> testToggleAttachment;
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.h:41:std::unique_ptr<juce::SliderParameterAttachment> maskDepthAttachment;
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.h:42:std::unique_ptr<juce::SliderParameterAttachment> brushStrengthAttachment;
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.h:43:std::unique_ptr<juce::ButtonParameterAttachment> debugToggleAttachment;
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.h:45:void setupControl(juce::Component& control, juce::Label& label, const juce::String& text);
C:\spectralCanvas Pro\Source\GUI\MinimalTopStrip.h:47:JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(MinimalTopStrip)
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:4:TopStrip::TopStrip(SpectralCanvasProAudioProcessor& processor, CanvasComponent& canvas)
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:17:loadSampleButton = std::make_unique<juce::TextButton>("Load Sample");
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:21:loadedSampleLabel.setText("No sample loaded", juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:22:loadedSampleLabel.setColour(juce::Label::textColourId, juce::Colours::lightgrey);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:23:loadedSampleLabel.setFont(juce::FontOptions().withPointHeight(12.0f));
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:27:modeSelector = std::make_unique<juce::ComboBox>("Mode");
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:35:modeLabel.setText("Mode", juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:36:modeLabel.setColour(juce::Label::textColourId, juce::Colours::white);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:37:modeLabel.setFont(juce::FontOptions().withPointHeight(12.0f));
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:40:blendSlider = std::make_unique<juce::Slider>(juce::Slider::LinearHorizontal, juce::Slider::NoTextBox);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:47:blendLabel.setText("Blend", juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:48:blendLabel.setColour(juce::Label::textColourId, juce::Colours::lightgrey);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:49:blendLabel.setFont(juce::FontOptions().withPointHeight(12.0f));
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:53:brushTypeSelector = std::make_unique<juce::ComboBox>("Brush Type");
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:62:brushTypeLabel.setText("Brush", juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:63:brushTypeLabel.setColour(juce::Label::textColourId, juce::Colours::white);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:64:brushTypeLabel.setFont(juce::FontOptions().withPointHeight(12.0f));
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:67:brushSizeSlider = std::make_unique<juce::Slider>(juce::Slider::LinearHorizontal, juce::Slider::NoTextBox);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:73:brushSizeLabel.setText("Size", juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:74:brushSizeLabel.setColour(juce::Label::textColourId, juce::Colours::white);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:75:brushSizeLabel.setFont(juce::FontOptions().withPointHeight(12.0f));
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:78:brushStrengthSlider = std::make_unique<juce::Slider>(juce::Slider::LinearHorizontal, juce::Slider::NoTextBox);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:84:brushStrengthLabel.setText("Strength", juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:85:brushStrengthLabel.setColour(juce::Label::textColourId, juce::Colours::white);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:86:brushStrengthLabel.setFont(juce::FontOptions().withPointHeight(12.0f));
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:90:snapToScaleButton = std::make_unique<juce::ToggleButton>("Snap to Scale");
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:94:tuningSelector = std::make_unique<juce::ComboBox>("Tuning");
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:102:fastPaintButton = std::make_unique<juce::ToggleButton>("Fast Paint");
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:110:void TopStrip::paint(juce::Graphics& g)
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:115:g.setColour(juce::Colour(0xffc0c0c0)); // Win95 button face color
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:119:g.setColour(juce::Colours::white); // Highlight
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:123:g.setColour(juce::Colour(0xff808080)); // Shadow
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:127:g.setColour(juce::Colour(0xff404040)); // Dark shadow
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:132:g.setColour(juce::Colours::black);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:133:g.setFont(juce::FontOptions().withPointHeight(14.0f).withStyle("Bold"));
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:134:g.drawText("SpectralCanvas Pro v2.0",
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:135:juce::Rectangle<int>(10, 8, 200, 18),
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:136:juce::Justification::centredLeft);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:139:g.setFont(juce::FontOptions().withPointHeight(11.0f));
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:140:g.setColour(juce::Colours::darkgreen);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:141:g.drawText("Audio: ON", getWidth() - 150, 8, 60, 16, juce::Justification::centredLeft);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:142:g.drawText("GPU: D3D11", getWidth() - 85, 8, 70, 16, juce::Justification::centredLeft);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:205:void TopStrip::buttonClicked(juce::Button* button)
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:229:void TopStrip::sliderValueChanged(juce::Slider* slider)
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:263:void TopStrip::comboBoxChanged(juce::ComboBox* comboBoxThatHasChanged)
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:275:blendLabel.setColour(juce::Label::textColourId,
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:276:isHybridMode ? juce::Colours::white : juce::Colours::lightgrey);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:311:modeSelector->setSelectedId(mode + 1, juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:316:blendSlider->setValue(blendParam->getValue(), juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:322:brushTypeSelector->setSelectedId(brushType + 1, juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:327:brushSizeSlider->setValue(brushSizeParam->getValue() * 128.0f, juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:332:brushStrengthSlider->setValue(brushStrengthParam->getValue(), juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:338:auto chooser = std::make_shared<juce::FileChooser>("Load Audio Sample",
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:339:juce::File::getSpecialLocation(juce::File::userDocumentsDirectory),
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:342:chooser->launchAsync(juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:343:[this, chooser](const juce::FileChooser& fc)
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:347:juce::Logger::writeToLog("Loading sample: " + selectedFile.getFullPathName());
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:353:juce::MessageManager::callAsync([this, selectedFile, loadSuccess]()
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:358:juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:359:loadedSampleLabel.setColour(juce::Label::textColourId, juce::Colours::lightgreen);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:362:modeSelector->setSelectedId(2, juce::sendNotificationSync);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:364:juce::Logger::writeToLog("Sample loaded successfully: " +
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:365:juce::String(audioProcessor.getSampleLoader().getNumSpectralFrames()) +
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:366:" spectral frames");
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:370:loadedSampleLabel.setText("Load failed!", juce::dontSendNotification);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:371:loadedSampleLabel.setColour(juce::Label::textColourId, juce::Colours::red);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:373:juce::AlertWindow::showMessageBoxAsync(juce::MessageBoxIconType::WarningIcon,
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:3:#include <juce_gui_basics/juce_gui_basics.h>
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:4:#include "../SpectralCanvasProAudioProcessor.h"
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:12:class TopStrip : public juce::Component,
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:13:public juce::Button::Listener,
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:14:public juce::Slider::Listener,
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:15:public juce::ComboBox::Listener
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:18:TopStrip(SpectralCanvasProAudioProcessor& processor, CanvasComponent& canvas);
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:21:void paint(juce::Graphics& g) override;
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:25:void buttonClicked(juce::Button* button) override;
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:26:void sliderValueChanged(juce::Slider* slider) override;
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:27:void comboBoxChanged(juce::ComboBox* comboBoxThatHasChanged) override;
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:33:SpectralCanvasProAudioProcessor& audioProcessor;
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:37:std::unique_ptr<juce::TextButton> loadSampleButton;
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:38:juce::Label loadedSampleLabel;
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:41:std::unique_ptr<juce::ComboBox> modeSelector;      // Synth | Resynth | Hybrid
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:42:std::unique_ptr<juce::Slider> blendSlider;         // 0..1 crossfade
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:43:juce::Label modeLabel;
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:44:juce::Label blendLabel;
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:47:std::unique_ptr<juce::ComboBox> brushTypeSelector; // Paint | Quantize | Erase | Comb
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:48:std::unique_ptr<juce::Slider> brushSizeSlider;     // 1..128 bins
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:49:std::unique_ptr<juce::Slider> brushStrengthSlider; // 0..1
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:50:juce::Label brushTypeLabel;
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:51:juce::Label brushSizeLabel;
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:52:juce::Label brushStrengthLabel;
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:55:std::unique_ptr<juce::ToggleButton> snapToScaleButton;
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:56:std::unique_ptr<juce::ComboBox> tuningSelector;    // 12-TET, Custom...
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:57:std::unique_ptr<juce::ToggleButton> fastPaintButton;
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:68:juce::Colour getNebulaAccentColor() const { return juce::Colour(0xff00bcd4); } // Cyan
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:70:JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(TopStrip)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:1:#include "D3D11Renderer_Fixed.h"
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:7:D3D11Renderer::D3D11Renderer() = default;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:8:D3D11Renderer::~D3D11Renderer() { shutdown(); }
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:10:bool D3D11Renderer::initialize(void* nativeWindowHandle, int width, int height)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:26:if (!createSpectralTexture(spectralWidth_, spectralHeight_))
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:39:void D3D11Renderer::shutdown()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:44:spectralSRV_.Reset();
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:45:spectralTexture_.Reset();
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:48:spectralPS_.Reset();
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:56:void D3D11Renderer::createDeviceAndSwapChain()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:60:flags |= D3D11_CREATE_DEVICE_DEBUG;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:68:Microsoft::WRL::ComPtr<ID3D11Device> dev;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:69:Microsoft::WRL::ComPtr<ID3D11DeviceContext> ctx;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:71:if (FAILED(D3D11CreateDevice(
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:73:req, (UINT)std::size(req), D3D11_SDK_VERSION, &dev, &got, &ctx)))
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:74:throw std::runtime_error("D3D11CreateDevice failed");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:103:void D3D11Renderer::createRenderTarget()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:105:Microsoft::WRL::ComPtr<ID3D11Texture2D> backBuf;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:106:if (FAILED(swapChain_->GetBuffer(0, __uuidof(ID3D11Texture2D),
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:113:D3D11_VIEWPORT vp{};
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:118:context_->RSSetViewports(1, &vp);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:121:void D3D11Renderer::destroyRenderTarget()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:126:void D3D11Renderer::checkCapabilities()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:128:supportsCompute_ = true; // D3D11 always supports compute shaders
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:133:supportsFloatTextures_ = SUCCEEDED(hr) && (formatSupport & D3D11_FORMAT_SUPPORT_TEXTURE2D);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:152:void D3D11Renderer::resizeBuffers(int width, int height)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:164:void D3D11Renderer::beginFrame()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:176:void D3D11Renderer::endFrame() { }
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:178:void D3D11Renderer::present()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:183:bool D3D11Renderer::createSpectralTexture(int width, int height)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:185:spectralWidth_ = width;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:186:spectralHeight_ = height;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:188:D3D11_TEXTURE2D_DESC desc = {};
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:195:desc.Usage = D3D11_USAGE_DYNAMIC;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:196:desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:197:desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:199:HRESULT hr = device_->CreateTexture2D(&desc, nullptr, &spectralTexture_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:202:hr = device_->CreateShaderResourceView(spectralTexture_.Get(), nullptr, &spectralSRV_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:206:D3D11_SAMPLER_DESC sampDesc = {};
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:207:sampDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:208:sampDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:209:sampDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:210:sampDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:211:sampDesc.MaxLOD = D3D11_FLOAT32_MAX;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:217:void D3D11Renderer::updateSpectralTexture(const SpectralFrame& frame)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:219:if (!spectralTexture_) return;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:222:ID3D11ShaderResourceView* nullSRV[1] = { nullptr };
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:223:context_->PSSetShaderResources(0, 1, nullSRV);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:225:D3D11_MAPPED_SUBRESOURCE mapped;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:226:HRESULT hr = context_->Map(spectralTexture_.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &mapped);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:233:for (int y = 0; y < spectralHeight_; ++y)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:235:for (int x = 0; x < spectralWidth_ && x < static_cast<int>(SpectralFrame::NUM_BINS); ++x)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:242:context_->Unmap(spectralTexture_.Get(), 0);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:246:bool D3D11Renderer::loadShaders() { return true; } // Stub for now
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:247:void D3D11Renderer::reloadShaders() { } // Stub for now
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:248:void D3D11Renderer::renderSpectralVisualization() { } // Stub for now
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:249:void D3D11Renderer::renderParticleSystem() { } // Stub for now
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:250:void D3D11Renderer::renderGestureTrails() { } // Stub for now
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:251:void D3D11Renderer::setColormap(int) { } // Stub for now
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:252:void D3D11Renderer::setParticleCount(int) { } // Stub for now
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:253:void D3D11Renderer::setAnimationSpeed(float) { } // Stub for now
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:255:bool D3D11Renderer::checkDeviceStatus()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:260:void D3D11Renderer::handleDeviceLost()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:14:#include <d3d11.h>
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:23:#pragma comment(lib, "d3d11.lib")
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:26:class D3D11Renderer : public GpuRenderer
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:29:D3D11Renderer();
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:30:~D3D11Renderer() override;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:41:bool createSpectralTexture(int width, int height) override;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:42:void updateSpectralTexture(const SpectralFrame& frame) override;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:45:bool loadShaders() override;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:46:void reloadShaders() override;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:48:void renderSpectralVisualization() override;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:52:void setColormap(int colormapType) override;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:60:bool supportsComputeShaders() const override { return supportsCompute_; }
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:69:// D3D11 Core objects
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:70:Microsoft::WRL::ComPtr<ID3D11Device> device_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:71:Microsoft::WRL::ComPtr<ID3D11DeviceContext> context_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:73:Microsoft::WRL::ComPtr<ID3D11RenderTargetView> rtv_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:75:// Spectral visualization resources
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:76:Microsoft::WRL::ComPtr<ID3D11Texture2D> spectralTexture_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:77:Microsoft::WRL::ComPtr<ID3D11ShaderResourceView> spectralSRV_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:78:Microsoft::WRL::ComPtr<ID3D11SamplerState> linearSampler_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:80:// Shader resources
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:81:Microsoft::WRL::ComPtr<ID3D11VertexShader> fullscreenVS_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:82:Microsoft::WRL::ComPtr<ID3D11PixelShader> spectralPS_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:92:int spectralWidth_ = 512;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:93:int spectralHeight_ = 256;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:98:int currentColormap_ = 0;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:1:#include "D3D11Renderer.h"
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:7:D3D11Renderer::D3D11Renderer() = default;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:8:D3D11Renderer::~D3D11Renderer() { shutdown(); }
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:10:bool D3D11Renderer::initialize(void* nativeWindowHandle, int width, int height)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:20:// Create basic D3D11 device and swap chain
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:32:HRESULT hr = D3D11CreateDeviceAndSwapChain(
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:34:nullptr, 0, D3D11_SDK_VERSION,
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:42:ComPtr<ID3D11Texture2D> backBuffer;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:43:hr = swapChain_->GetBuffer(0, __uuidof(ID3D11Texture2D), (void**)&backBuffer);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:53:void D3D11Renderer::shutdown()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:63:void D3D11Renderer::beginFrame()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:71:D3D11_VIEWPORT viewport = {};
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:75:deviceContext_->RSSetViewports(1, &viewport);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:78:void D3D11Renderer::endFrame() { }
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:80:void D3D11Renderer::present()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:85:bool D3D11Renderer::createSpectralTexture(int width, int height)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:87:spectralWidth_ = width;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:88:spectralHeight_ = height;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:90:D3D11_TEXTURE2D_DESC desc = {};
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:97:desc.Usage = D3D11_USAGE_DYNAMIC;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:98:desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:99:desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:101:HRESULT hr = device_->CreateTexture2D(&desc, nullptr, &spectralTexture_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:104:hr = device_->CreateShaderResourceView(spectralTexture_.Get(), nullptr, &spectralSRV_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:108:void D3D11Renderer::updateSpectralTexture(const SpectralFrame& frame)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:110:if (!spectralTexture_) return;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:112:D3D11_MAPPED_SUBRESOURCE mapped;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:113:HRESULT hr = deviceContext_->Map(spectralTexture_.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &mapped);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:119:for (int y = 0; y < spectralHeight_; ++y)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:121:for (int x = 0; x < spectralWidth_ && x < static_cast<int>(SpectralFrame::NUM_BINS); ++x)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:126:deviceContext_->Unmap(spectralTexture_.Get(), 0);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:130:void D3D11Renderer::resizeBuffers(int width, int height)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:139:ComPtr<ID3D11Texture2D> backBuffer;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:140:swapChain_->GetBuffer(0, __uuidof(ID3D11Texture2D), (void**)&backBuffer);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:145:bool D3D11Renderer::loadShaders() { return true; }
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:146:void D3D11Renderer::reloadShaders() { }
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:147:void D3D11Renderer::renderSpectralVisualization() { }
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:148:void D3D11Renderer::renderParticleSystem() { }
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:149:void D3D11Renderer::renderGestureTrails() { }
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:150:void D3D11Renderer::setColormap(int) { }
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:151:void D3D11Renderer::setParticleCount(int) { }
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:152:void D3D11Renderer::setAnimationSpeed(float) { }
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:153:bool D3D11Renderer::checkDeviceStatus() { return device_ != nullptr; }
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:154:void D3D11Renderer::handleDeviceLost() { }
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:1:#include "D3D11Renderer.h"
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:8:D3D11Renderer::D3D11Renderer() = default;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:10:D3D11Renderer::~D3D11Renderer()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:15:bool D3D11Renderer::initialize(void* nativeWindowHandle, int width, int height)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:30:// Create D3D11 device and context
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:33:lastError_ = "Failed to create D3D11 device";
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:54:// Create shaders
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:55:if (!createShaders())
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:57:lastError_ = "Failed to create shaders";
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:75:// Create spectral texture
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:76:if (!createSpectralTexture(spectralWidth_, spectralHeight_))
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:78:lastError_ = "Failed to create spectral texture";
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:94:void D3D11Renderer::shutdown()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:101:cleanupShaders();
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:112:bool D3D11Renderer::createDevice(HWND /*windowHandle*/)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:117://     flags |= D3D11_CREATE_DEVICE_DEBUG;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:124:Microsoft::WRL::ComPtr<ID3D11Device> dev;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:125:Microsoft::WRL::ComPtr<ID3D11DeviceContext> ctx;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:127:HRESULT hr = D3D11CreateDevice(nullptr, D3D_DRIVER_TYPE_HARDWARE, nullptr, flags,
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:128:req, (UINT)std::size(req), D3D11_SDK_VERSION,
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:134:hr = D3D11CreateDevice(nullptr, D3D_DRIVER_TYPE_WARP, nullptr, flags,
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:135:req, (UINT)std::size(req), D3D11_SDK_VERSION,
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:139:lastError_ = "D3D11CreateDevice (HW + WARP) failed";
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:149:bool D3D11Renderer::createSwapChain(HWND windowHandle, int width, int height)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:155:logD3D11Error(hr, "QueryInterface IDXGIDevice");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:163:logD3D11Error(hr, "GetAdapter");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:171:logD3D11Error(hr, "GetParent IDXGIFactory2");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:197:logD3D11Error(hr, "CreateSwapChainForHwnd");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:204:bool D3D11Renderer::createRenderTargets()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:207:ComPtr<ID3D11Texture2D> backBuffer;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:208:HRESULT hr = swapChain_->GetBuffer(0, __uuidof(ID3D11Texture2D), &backBuffer);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:211:logD3D11Error(hr, "GetBuffer");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:219:logD3D11Error(hr, "CreateRenderTargetView");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:224:D3D11_TEXTURE2D_DESC depthDesc = {};
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:232:depthDesc.Usage = D3D11_USAGE_DEFAULT;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:233:depthDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:235:ComPtr<ID3D11Texture2D> depthBuffer;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:239:logD3D11Error(hr, "CreateTexture2D (depth)");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:247:logD3D11Error(hr, "CreateDepthStencilView");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:254:bool D3D11Renderer::createShaders()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:256:// For now, create minimal shaders - full implementation will load from .hlsl files
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:258:// Simple fullscreen vertex shader
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:276:// Simple spectral visualization pixel shader
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:277:const char* spectralPS = R"(
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:278:Texture2D spectralTexture : register(t0);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:281:cbuffer SpectralConstants : register(b0)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:284:float colormapType;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:307:float spectralValue = spectralTexture.Sample(linearSampler, texCoord).r;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:308:spectralValue = pow(spectralValue * brightness, contrast);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:310:float3 color = viridis(spectralValue);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:320:// Compile shaders
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:323:if (!compileShaderFromFile("", "main", "vs_5_0", &vsBlob))
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:325:// Fallback to inline shader
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:332:lastError_ = "Failed to compile fullscreen vertex shader";
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:338:spectralPS, strlen(spectralPS), nullptr, nullptr, nullptr,
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:343:lastError_ = "Failed to compile spectral pixel shader";
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:347:// Create shader objects
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:348:hr = device_->CreateVertexShader(vsBlob->GetBufferPointer(), vsBlob->GetBufferSize(), nullptr, &fullscreenVS_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:351:logD3D11Error(hr, "CreateVertexShader");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:355:hr = device_->CreatePixelShader(psBlob->GetBufferPointer(), psBlob->GetBufferSize(), nullptr, &spectralPS_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:358:logD3D11Error(hr, "CreatePixelShader");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:365:bool D3D11Renderer::createBuffers()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:368:D3D11_BUFFER_DESC cbDesc = {};
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:369:cbDesc.Usage = D3D11_USAGE_DYNAMIC;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:370:cbDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:371:cbDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:373:cbDesc.ByteWidth = sizeof(SpectralConstants);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:374:HRESULT hr = device_->CreateBuffer(&cbDesc, nullptr, &spectralConstants_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:377:logD3D11Error(hr, "CreateBuffer (spectral constants)");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:385:logD3D11Error(hr, "CreateBuffer (particle constants)");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:393:logD3D11Error(hr, "CreateBuffer (brush constants)");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:400:bool D3D11Renderer::createStates()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:403:D3D11_RASTERIZER_DESC rastDesc = {};
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:404:rastDesc.CullMode = D3D11_CULL_NONE;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:405:rastDesc.FillMode = D3D11_FILL_SOLID;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:411:logD3D11Error(hr, "CreateRasterizerState");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:416:D3D11_BLEND_DESC blendDesc = {};
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:418:blendDesc.RenderTarget[0].SrcBlend = D3D11_BLEND_SRC_ALPHA;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:419:blendDesc.RenderTarget[0].DestBlend = D3D11_BLEND_ONE;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:420:blendDesc.RenderTarget[0].BlendOp = D3D11_BLEND_OP_ADD;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:421:blendDesc.RenderTarget[0].SrcBlendAlpha = D3D11_BLEND_ONE;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:422:blendDesc.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_ZERO;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:423:blendDesc.RenderTarget[0].BlendOpAlpha = D3D11_BLEND_OP_ADD;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:424:blendDesc.RenderTarget[0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:429:logD3D11Error(hr, "CreateBlendState");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:434:D3D11_SAMPLER_DESC sampDesc = {};
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:435:sampDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:436:sampDesc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:437:sampDesc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:438:sampDesc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:439:sampDesc.MaxLOD = D3D11_FLOAT32_MAX;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:444:logD3D11Error(hr, "CreateSamplerState");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:451:void D3D11Renderer::checkCapabilities()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:453:D3D11_FEATURE_DATA_D3D11_OPTIONS options = {};
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:454:HRESULT hr = device_->CheckFeatureSupport(D3D11_FEATURE_D3D11_OPTIONS, &options, sizeof(options));
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:458:supportsCompute_ = true; // D3D11 always supports compute shaders
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:464:supportsFloatTextures_ = SUCCEEDED(hr) && (formatSupport & D3D11_FORMAT_SUPPORT_TEXTURE2D);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:483:bool D3D11Renderer::createSpectralTexture(int width, int height)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:485:spectralWidth_ = width;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:486:spectralHeight_ = height;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:488:// Create texture for spectral data
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:489:D3D11_TEXTURE2D_DESC texDesc = {};
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:494:texDesc.Format = DXGI_FORMAT_R32_FLOAT; // Single channel float for magnitude
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:496:texDesc.Usage = D3D11_USAGE_DYNAMIC;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:497:texDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:498:texDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:500:HRESULT hr = device_->CreateTexture2D(&texDesc, nullptr, &spectralTexture_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:503:logD3D11Error(hr, "CreateTexture2D (spectral)");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:507:// Create shader resource view
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:508:hr = device_->CreateShaderResourceView(spectralTexture_.Get(), nullptr, &spectralSRV_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:511:logD3D11Error(hr, "CreateShaderResourceView (spectral)");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:518:bool D3D11Renderer::createMaskAtlas()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:520:// Create MaskAtlas texture (same dimensions as spectral texture)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:522:D3D11_TEXTURE2D_DESC texDesc = {};
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:523:texDesc.Width = spectralWidth_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:524:texDesc.Height = spectralHeight_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:529:texDesc.Usage = D3D11_USAGE_DEFAULT;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:530:texDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:536:logD3D11Error(hr, "CreateTexture2D (MaskAtlas)");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:540:// Create shader resource view for sampling in composite pass
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:541:hr = device_->CreateShaderResourceView(maskAtlas_.Get(), nullptr, &maskAtlasSRV_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:544:logD3D11Error(hr, "CreateShaderResourceView (MaskAtlas)");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:552:logD3D11Error(hr, "CreateRenderTargetView (MaskAtlas)");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:557:D3D11_TEXTURE2D_DESC stagingDesc = {};
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:559:stagingDesc.Height = spectralHeight_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:564:stagingDesc.Usage = D3D11_USAGE_STAGING;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:566:stagingDesc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:573:logD3D11Error(hr, "CreateTexture2D (MaskStaging)");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:588:void D3D11Renderer::setupBrushBlendStates()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:593:D3D11_BLEND_DESC addBlendDesc = {};
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:595:addBlendDesc.RenderTarget[0].SrcBlend = D3D11_BLEND_ONE;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:596:addBlendDesc.RenderTarget[0].DestBlend = D3D11_BLEND_ONE;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:597:addBlendDesc.RenderTarget[0].BlendOp = D3D11_BLEND_OP_ADD;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:598:addBlendDesc.RenderTarget[0].SrcBlendAlpha = D3D11_BLEND_ONE;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:599:addBlendDesc.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_ONE;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:600:addBlendDesc.RenderTarget[0].BlendOpAlpha = D3D11_BLEND_OP_ADD;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:601:addBlendDesc.RenderTarget[0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:604:if (FAILED(hr)) logD3D11Error(hr, "CreateBlendState (Add)");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:607:D3D11_BLEND_DESC subtractBlendDesc = addBlendDesc;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:608:subtractBlendDesc.RenderTarget[0].BlendOp = D3D11_BLEND_OP_REV_SUBTRACT;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:611:if (FAILED(hr)) logD3D11Error(hr, "CreateBlendState (Subtract)");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:614:D3D11_BLEND_DESC alphaBlendDesc = {};
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:616:alphaBlendDesc.RenderTarget[0].SrcBlend = D3D11_BLEND_SRC_ALPHA;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:617:alphaBlendDesc.RenderTarget[0].DestBlend = D3D11_BLEND_ONE;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:618:alphaBlendDesc.RenderTarget[0].BlendOp = D3D11_BLEND_OP_ADD;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:619:alphaBlendDesc.RenderTarget[0].SrcBlendAlpha = D3D11_BLEND_ONE;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:620:alphaBlendDesc.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_ONE;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:621:alphaBlendDesc.RenderTarget[0].BlendOpAlpha = D3D11_BLEND_OP_ADD;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:622:alphaBlendDesc.RenderTarget[0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:625:if (FAILED(hr)) logD3D11Error(hr, "CreateBlendState (Alpha)");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:628:void D3D11Renderer::beginFrame()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:638:deviceContext_->ClearDepthStencilView(depthStencilView_.Get(), D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:644:D3D11_VIEWPORT viewport = {};
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:649:deviceContext_->RSSetViewports(1, &viewport);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:655:void D3D11Renderer::endFrame()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:660:void D3D11Renderer::present()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:668:void D3D11Renderer::updateSpectralTexture(const SpectralFrame& frame)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:670:if (!spectralTexture_ || !deviceContext_)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:673:D3D11_MAPPED_SUBRESOURCE mappedResource;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:674:HRESULT hr = deviceContext_->Map(spectralTexture_.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:678:// Copy spectral magnitude data to texture
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:683:for (int y = 0; y < spectralHeight_; ++y)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:685:for (int x = 0; x < spectralWidth_ && x < static_cast<int>(SpectralFrame::NUM_BINS); ++x)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:691:deviceContext_->Unmap(spectralTexture_.Get(), 0);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:694:void D3D11Renderer::updateConstants()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:696:// Update spectral constants
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:697:if (!deviceContext_ || !spectralConstants_)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:699:D3D11_MAPPED_SUBRESOURCE mappedResource;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:700:HRESULT hr = deviceContext_->Map(spectralConstants_.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:703:SpectralConstants* constants = static_cast<SpectralConstants*>(mappedResource.pData);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:708:constants->colormapType = static_cast<float>(currentColormap_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:714:deviceContext_->Unmap(spectralConstants_.Get(), 0);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:718:void D3D11Renderer::renderSpectralVisualization()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:723:// Set shaders
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:724:deviceContext_->VSSetShader(fullscreenVS_.Get(), nullptr, 0);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:725:deviceContext_->PSSetShader(spectralPS_.Get(), nullptr, 0);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:728:deviceContext_->PSSetShaderResources(0, 1, spectralSRV_.GetAddressOf());
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:729:deviceContext_->PSSetSamplers(0, 1, linearSampler_.GetAddressOf());
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:730:deviceContext_->PSSetConstantBuffers(0, 1, spectralConstants_.GetAddressOf());
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:733:deviceContext_->RSSetState(rasterizerState_.Get());
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:736:deviceContext_->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:742:void D3D11Renderer::renderParticleSystem()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:750:void D3D11Renderer::renderGestureTrails()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:758:bool D3D11Renderer::loadShaders()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:760:return createShaders(); // For now, same as create
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:763:void D3D11Renderer::reloadShaders()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:765:cleanupShaders();
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:766:createShaders();
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:769:void D3D11Renderer::resizeBuffers(int width, int height)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:780:logD3D11Error(hr, "ResizeBuffers");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:786:void D3D11Renderer::setColormap(int colormapType)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:788:currentColormap_ = colormapType;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:791:void D3D11Renderer::setParticleCount(int count)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:796:void D3D11Renderer::setAnimationSpeed(float speed)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:801:bool D3D11Renderer::checkDeviceStatus()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:810:void D3D11Renderer::handleDeviceLost()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:816:bool D3D11Renderer::compileShaderFromFile(const std::string& filename, const std::string& entryPoint,
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:823:// TODO: Load and compile HLSL files from disk
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:824:return false; // Fall back to inline shaders for now
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:827:void D3D11Renderer::renderBrushStroke(float centerU, float centerV, float sizeU, float sizeV,
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:837:D3D11_VIEWPORT viewport = {};
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:838:viewport.Width = static_cast<float>(spectralWidth_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:839:viewport.Height = static_cast<float>(spectralHeight_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:842:deviceContext_->RSSetViewports(1, &viewport);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:876:D3D11_VIEWPORT mainViewport = {};
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:881:deviceContext_->RSSetViewports(1, &mainViewport);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:884:void D3D11Renderer::renderBrushQuad(const BrushConstants& brushData)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:887:D3D11_MAPPED_SUBRESOURCE mappedResource;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:888:HRESULT hr = deviceContext_->Map(brushConstants_.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:895:// Set shaders (TODO: Create brush shaders)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:896:deviceContext_->VSSetShader(brushVS_.Get(), nullptr, 0);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:897:deviceContext_->PSSetShader(brushPS_.Get(), nullptr, 0);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:900:deviceContext_->VSSetConstantBuffers(0, 1, brushConstants_.GetAddressOf());
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:901:deviceContext_->PSSetConstantBuffers(0, 1, brushConstants_.GetAddressOf());
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:903:// Render fullscreen quad (will be clipped by brush shader)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:909:deviceContext_->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:916:bool D3D11Renderer::readbackMaskColumn(int columnIndex, float* outputColumn, int numBins)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:918:if (!maskAtlas_ || columnIndex < 0 || columnIndex >= spectralWidth_)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:922:D3D11_BOX sourceBox = {};
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:926:sourceBox.bottom = spectralHeight_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:942:D3D11_MAPPED_SUBRESOURCE mappedResource;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:943:HRESULT hr = deviceContext_->Map(readbackTex.Get(), 0, D3D11_MAP_READ, 0, &mappedResource);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:955:for (int bin = 0; bin < numBins && bin < spectralHeight_; ++bin)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:992:void D3D11Renderer::logD3D11Error(HRESULT hr, const std::string& operation)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:999:void D3D11Renderer::cleanupRenderTargets()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:1005:void D3D11Renderer::cleanupShaders()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:1008:spectralPS_.Reset();
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:1009:spectralCS_.Reset();
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:1017:void D3D11Renderer::cleanupBuffers()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:1019:spectralConstants_.Reset();
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:1027:void D3D11Renderer::cleanupMaskAtlas()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:6:#include <d3d11.h>
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:15:class D3D11Renderer : public GpuRenderer
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:18:D3D11Renderer();
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:19:~D3D11Renderer() override;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:30:bool createSpectralTexture(int width, int height) override;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:31:void updateSpectralTexture(const SpectralFrame& frame) override;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:34:bool loadShaders() override;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:35:void reloadShaders() override;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:37:void renderSpectralVisualization() override;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:41:void setColormap(int colormapType) override;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:49:bool supportsComputeShaders() const override { return supportsCompute_; }
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:58:// D3D11 Core objects
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:59:ComPtr<ID3D11Device> device_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:60:ComPtr<ID3D11DeviceContext> deviceContext_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:62:ComPtr<ID3D11RenderTargetView> renderTargetView_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:63:ComPtr<ID3D11DepthStencilView> depthStencilView_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:65:// Spectral visualization resources
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:66:ComPtr<ID3D11Texture2D> spectralTexture_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:67:ComPtr<ID3D11ShaderResourceView> spectralSRV_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:68:ComPtr<ID3D11UnorderedAccessView> spectralUAV_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:71:ComPtr<ID3D11Texture2D> maskAtlas_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:72:ComPtr<ID3D11ShaderResourceView> maskAtlasSRV_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:73:ComPtr<ID3D11RenderTargetView> maskAtlasRTV_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:77:ComPtr<ID3D11Texture2D> maskStagingTextures_[MASK_READBACK_COUNT];
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:81:// Shader resources
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:82:ComPtr<ID3D11VertexShader> fullscreenVS_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:83:ComPtr<ID3D11PixelShader> spectralPS_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:84:ComPtr<ID3D11ComputeShader> spectralCS_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:85:ComPtr<ID3D11VertexShader> particleVS_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:86:ComPtr<ID3D11GeometryShader> particleGS_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:87:ComPtr<ID3D11PixelShader> particlePS_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:89:// Brush rendering shaders
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:90:ComPtr<ID3D11VertexShader> brushVS_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:91:ComPtr<ID3D11PixelShader> brushPS_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:94:struct SpectralConstants
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:97:float colormapType;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:124:ComPtr<ID3D11Buffer> spectralConstants_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:125:ComPtr<ID3D11Buffer> particleConstants_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:126:ComPtr<ID3D11Buffer> brushConstants_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:129:ComPtr<ID3D11Buffer> fullscreenQuadVB_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:130:ComPtr<ID3D11Buffer> particleVB_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:131:ComPtr<ID3D11Buffer> particleInstanceVB_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:134:ComPtr<ID3D11RasterizerState> rasterizerState_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:135:ComPtr<ID3D11BlendState> blendState_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:136:ComPtr<ID3D11DepthStencilState> depthStencilState_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:137:ComPtr<ID3D11SamplerState> linearSampler_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:140:ComPtr<ID3D11BlendState> brushAddBlend_;      // Add (paint)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:141:ComPtr<ID3D11BlendState> brushSubtractBlend_; // Subtract (erase)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:142:ComPtr<ID3D11BlendState> brushAlphaBlend_;    // Alpha blend (soft tools)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:152:int spectralWidth_ = 512;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:153:int spectralHeight_ = 256;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:156:int currentColormap_ = 0; // 0=Viridis, 1=Magma
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:161:ComPtr<ID3D11Query> frameTimeQuery_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:169:bool createShaders();
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:175:bool compileShaderFromFile(const std::string& filename, const std::string& entryPoint,
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:177:void logD3D11Error(HRESULT hr, const std::string& operation);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:189:void cleanupShaders();
C:\spectralCanvas Pro\Source\Viz\GpuRenderer.cpp:4:#include "backends/D3D11Renderer.h"
C:\spectralCanvas Pro\Source\Viz\GpuRenderer.cpp:10:return std::make_unique<D3D11Renderer>();
C:\spectralCanvas Pro\Source\Viz\GpuRenderer.h:24:virtual bool createSpectralTexture(int width, int height) = 0;
C:\spectralCanvas Pro\Source\Viz\GpuRenderer.h:25:virtual void updateSpectralTexture(const SpectralFrame& frame) = 0;
C:\spectralCanvas Pro\Source\Viz\GpuRenderer.h:28:// Shader management
C:\spectralCanvas Pro\Source\Viz\GpuRenderer.h:29:virtual bool loadShaders() = 0;
C:\spectralCanvas Pro\Source\Viz\GpuRenderer.h:30:virtual void reloadShaders() = 0;
C:\spectralCanvas Pro\Source\Viz\GpuRenderer.h:33:virtual void renderSpectralVisualization() = 0;
C:\spectralCanvas Pro\Source\Viz\GpuRenderer.h:38:virtual void setColormap(int colormapType) = 0;
C:\spectralCanvas Pro\Source\Viz\GpuRenderer.h:48:virtual bool supportsComputeShaders() const = 0;
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:4:#include <d3d11.h>
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:18:* RenderThread - Dedicated D3D11 immediate context owner
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:20:* Implements Pattern #6: Renderer-owns-D3D11 Immediate Context
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:23:* - Only ONE thread owns the D3D11 immediate context and calls Present()
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:24:* - UI thread posts render commands via lock-free queue
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:25:* - GPU thread processes commands and presents frames
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:36:UpdateSpectralTexture,
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:39:RenderSpectralFrame,
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:46:// POD render command (lock-free queue compatible)
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:114:// D3D11 core objects (owned by render thread)
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:115:ComPtr<ID3D11Device> device_;
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:116:ComPtr<ID3D11DeviceContext> immediateContext_;
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:118:ComPtr<ID3D11RenderTargetView> renderTargetView_;
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:119:ComPtr<ID3D11DepthStencilView> depthStencilView_;
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:122:ComPtr<ID3D11Buffer> dynamicVertexBuffer_;
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:123:ComPtr<ID3D11Buffer> dynamicConstantBuffer_;
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:124:ComPtr<ID3D11Texture2D> dynamicSpectralTexture_;
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:125:ComPtr<ID3D11ShaderResourceView> spectralTextureSRV_;
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:129:ComPtr<ID3D11Texture2D> maskAtlasTextures_[MASK_ATLAS_COUNT];
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:130:ComPtr<ID3D11RenderTargetView> maskAtlasRTVs_[MASK_ATLAS_COUNT];
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:131:ComPtr<ID3D11ShaderResourceView> maskAtlasSRVs_[MASK_ATLAS_COUNT];
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:134:// Command queue (lock-free SPSC)
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:136:using CommandQueue = SpscRing<RenderCommand, COMMAND_QUEUE_SIZE>;
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:157:// D3D11 setup and management
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:167:bool createSpectralTexture(int width, int height);
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:180:void renderSpectralVisualization();
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:210:// D3D11 debug helpers
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:228:* RAII helper for D3D11 resource mapping
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:231:class D3D11MappedResource
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:234:D3D11MappedResource(ID3D11DeviceContext* context, ID3D11Resource* resource,
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:235:UINT subresource, D3D11_MAP mapType, UINT mapFlags = 0)
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:242:~D3D11MappedResource()
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:256:D3D11MappedResource(const D3D11MappedResource&) = delete;
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:257:D3D11MappedResource& operator=(const D3D11MappedResource&) = delete;
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:258:D3D11MappedResource(D3D11MappedResource&&) = default;
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:259:D3D11MappedResource& operator=(D3D11MappedResource&&) = default;
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:262:ID3D11DeviceContext* context_;
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:263:ID3D11Resource* resource_;
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:265:D3D11_MAPPED_SUBRESOURCE mappedResource_{};
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:1:#include "SpectralCanvasProAudioProcessor.h"
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:2:#include "SpectralCanvasProEditor.h"
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:5:SpectralCanvasProAudioProcessor::SpectralCanvasProAudioProcessor()
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:7:.withInput("Input", juce::AudioChannelSet::stereo(), true)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:8:.withOutput("Output", juce::AudioChannelSet::stereo(), true)),
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:13:SpectralCanvasProAudioProcessor::~SpectralCanvasProAudioProcessor()
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:25:void SpectralCanvasProAudioProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:38:maskTestFeeder.initialize(sampleRate, 257); // NUM_BINS for 512-point FFT
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:40:// Initialize RT-safe spectral processing components
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:41:spectralEngine = std::make_unique<SpectralEngine>();
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:42:spectralEngine->initialize(sampleRate, samplesPerBlock);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:44:// Connect SampleLoader to SpectralEngine (RT-safe pointer sharing)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:45:spectralEngine->setSampleLoader(&sampleLoader);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:48:processedSampleCount_.store(0, std::memory_order_relaxed);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:55:spectralDataQueue.clear();
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:60:juce::Logger::writeToLog("[AUDIO] MaskQueue addr=" + juce::String::toHexString(reinterpret_cast<uintptr_t>(&maskColumnQueue)) + " sizeof(MaskColumn)=" + juce::String(sizeof(MaskColumn)));
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:64:const int fftSize = 512;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:65:const int numBins = fftSize / 2 + 1;  // 257
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:66:const int channels = getTotalNumOutputChannels();
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:68:spectralStub.prepare(sampleRate, fftSize, numBins, channels);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:69:keyFilter.prepare(fftSize, numBins, sampleRate);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:92:void SpectralCanvasProAudioProcessor::releaseResources()
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:94:if (spectralEngine)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:95:spectralEngine->reset();
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:102:void SpectralCanvasProAudioProcessor::setAudioPathFromParams()
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:114:void SpectralCanvasProAudioProcessor::rtResetPhase4_() noexcept
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:116:spectralStub.reset(); // zero phases/magnitudes; RT-safe
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:119:void SpectralCanvasProAudioProcessor::rtResetTestFeeder_() noexcept
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:125:int SpectralCanvasProAudioProcessor::getActiveBinCount() const noexcept
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:127:return spectralStub.getActiveBinCount();
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:130:int SpectralCanvasProAudioProcessor::getNumBins() const noexcept
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:132:return spectralStub.getNumBins();
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:136:void SpectralCanvasProAudioProcessor::processBlock(juce::AudioBuffer<float>& buffer,
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:137:juce::MidiBuffer& midiMessages) noexcept
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:139:juce::ignoreUnused(midiMessages);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:140:juce::ScopedNoDenormals noDenormals;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:167:const float oscGain = juce::jlimit(1.0e-6f, 1.0f, oscGainRaw);  // Clamp gain
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:174:spectralStub.popAllMaskColumnsInto(maskColumnQueue); // discard all data
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:188:const float incr = juce::MathConstants<float>::twoPi * freq / static_cast<float>(getSampleRate());
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:193:if (testPhase >= juce::MathConstants<float>::twoPi)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:194:testPhase -= juce::MathConstants<float>::twoPi;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:197:for (int ch = 0; ch < buffer.getNumChannels(); ++ch)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:213:spectralStub.popAllMaskColumnsInto(maskColumnQueue);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:217:keyFilter.apply(spectralStub.getMagnitudesWritePtr(), 257);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:224:spectralStub.process(buffer, oscGain);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:237:float currentRms = buffer.getNumChannels() > 0 ? buffer.getRMSLevel(0, 0, N) : 0.0f;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:246:const float inc  = juce::MathConstants<float>::twoPi * 440.0f / (float)sr;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:249:if (chirpPhase >= juce::MathConstants<float>::twoPi)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:250:chirpPhase -= juce::MathConstants<float>::twoPi;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:252:for (int ch = 0; ch < buffer.getNumChannels(); ++ch)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:260:const float rms = buffer.getNumChannels() > 0
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:269:#if JUCE_DEBUG
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:276:juce::Logger::writeToLog(juce::String::formatted("Audio path (%s) producing silence", pathName));
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:283:void SpectralCanvasProAudioProcessor::fallbackBeep(juce::AudioBuffer<float>& buffer) noexcept
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:286:const float inc = float(2.0 * juce::MathConstants<double>::pi * 220.0 / getSampleRate());
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:290:if (ph > juce::MathConstants<float>::twoPi)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:291:ph -= juce::MathConstants<float>::twoPi;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:293:for (int ch = 0; ch < buffer.getNumChannels(); ++ch)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:299:void SpectralCanvasProAudioProcessor::generateFallbackBeep(juce::AudioBuffer<float>& buffer, int numSamples) noexcept
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:303:const float phaseIncrement = frequency * 2.0f * juce::MathConstants<float>::pi / static_cast<float>(currentSampleRate);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:310:// Write to all output channels
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:311:for (int channel = 0; channel < buffer.getNumChannels(); ++channel)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:313:buffer.setSample(channel, sample, sampleValue);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:317:if (phase >= 2.0f * juce::MathConstants<float>::pi)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:318:phase -= 2.0f * juce::MathConstants<float>::pi;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:323:void SpectralCanvasProAudioProcessor::parameterChanged(const juce::String& parameterID, float newValue)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:360:void SpectralCanvasProAudioProcessor::parameterChanged(const juce::String&, float)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:366:juce::AudioProcessorEditor* SpectralCanvasProAudioProcessor::createEditor()
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:368:return new SpectralCanvasProEditor(*this);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:371:void SpectralCanvasProAudioProcessor::getStateInformation(juce::MemoryBlock& destData)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:374:std::unique_ptr<juce::XmlElement> xml(state.createXml());
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:378:void SpectralCanvasProAudioProcessor::setStateInformation(const void* data, int sizeInBytes)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:380:std::unique_ptr<juce::XmlElement> xmlState(getXmlFromBinary(data, sizeInBytes));
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:384:apvts.replaceState(juce::ValueTree::fromXml(*xmlState));
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:388:bool SpectralCanvasProAudioProcessor::loadSampleFile(const juce::File& audioFile)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:394:void SpectralCanvasProAudioProcessor::generateImmediateAudioFeedback()
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:400:bool SpectralCanvasProAudioProcessor::pushMaskColumn(const MaskColumn& mask)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:403:juce::Logger::writeToLog("*** PUSHMASKCOLUMN CALLED! *** Path=" + juce::String(static_cast<int>(getCurrentPath())));
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:409:juce::Logger::writeToLog("pushMaskColumn rejected - not Phase4 path");
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:414:juce::Logger::writeToLog("pushMaskColumn proceeding to queue...");
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:461:int SpectralCanvasProAudioProcessor::getBlockSize() const
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:466:double SpectralCanvasProAudioProcessor::getSampleRate() const
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:471:SpectralCanvasProAudioProcessor::PerformanceMetrics SpectralCanvasProAudioProcessor::getPerformanceMetrics() const
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:484:metrics.processedSamples = processedSampleCount_.load(std::memory_order_relaxed);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:493:juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:495:return new SpectralCanvasProAudioProcessor();
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:3:#include <juce_audio_processors/juce_audio_processors.h>
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:4:#include <juce_dsp/juce_dsp.h>
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:9:#include "DSP/SpectralEngine.h"
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:15:#include "DSP/SpectralEngineStub.h"
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:18:class SpectralCanvasProAudioProcessor : public juce::AudioProcessor,
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:19:public juce::AudioProcessorValueTreeState::Listener
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:30:SpectralCanvasProAudioProcessor();
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:31:~SpectralCanvasProAudioProcessor() override;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:38:void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) noexcept override;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:40:juce::AudioProcessorEditor* createEditor() override;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:43:const juce::String getName() const override { return JucePlugin_Name; }
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:51:void setCurrentProgram(int index) override { juce::ignoreUnused(index); }
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:52:const juce::String getProgramName(int index) override { juce::ignoreUnused(index); return {}; }
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:53:void changeProgramName(int index, const juce::String& newName) override { juce::ignoreUnused(index, newName); }
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:55:void getStateInformation(juce::MemoryBlock& destData) override;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:59:juce::AudioProcessorValueTreeState& getValueTreeState() { return apvts; }
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:62:SpectralDataQueue& getSpectralDataQueue() { return spectralDataQueue; }
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:67:bool loadSampleFile(const juce::File& audioFile);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:85:uint64_t processedSamples = 0;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:117:// SpectralEngineStub diagnostics
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:118:uint64_t getMaskPopCount() const noexcept { return spectralStub.getPopCount(); }
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:119:float getMaxMagnitude() const noexcept { return spectralStub.getMaxMagnitude(); }
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:129:void parameterChanged(const juce::String& parameterID, float newValue) override;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:132:juce::AudioProcessorValueTreeState apvts;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:138:AudioPath lastPath_ { AudioPath::Silent }; // accessed only from audio thread
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:142:void generateFallbackBeep(juce::AudioBuffer<float>& buffer, int numSamples) noexcept;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:143:void fallbackBeep(juce::AudioBuffer<float>& buffer) noexcept;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:151:// Inter-thread communication (lock-free)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:152:SpectralDataQueue spectralDataQueue;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:160:// RT-safe spectral processing
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:161:std::unique_ptr<SpectralEngine> spectralEngine;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:171:dsp::SpectralEngineStub spectralStub;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:187:std::atomic<uint64_t> processedSampleCount_{0};
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:195:// Debug tap for SPSC integrity diagnosis
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:198:JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(SpectralCanvasProAudioProcessor)
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.cpp:1:#include "SpectralCanvasProEditor.h"
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.cpp:4:SpectralCanvasProEditor::SpectralCanvasProEditor(SpectralCanvasProAudioProcessor& p)
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.cpp:13:// Minimal top strip with essential controls only
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.cpp:23:SpectralCanvasProEditor::~SpectralCanvasProEditor()
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.cpp:29:void SpectralCanvasProEditor::paint(juce::Graphics& g)
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.cpp:32:g.fillAll(juce::Colour(0xff0a0a0f));
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.cpp:35:void SpectralCanvasProEditor::resized()
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.h:3:#include <juce_gui_basics/juce_gui_basics.h>
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.h:4:#include "SpectralCanvasProAudioProcessor.h"
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.h:12:* - MinimalTopStrip for essential controls only
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.h:17:class SpectralCanvasProEditor : public juce::AudioProcessorEditor
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.h:20:SpectralCanvasProEditor(SpectralCanvasProAudioProcessor&);
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.h:21:~SpectralCanvasProEditor() override;
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.h:23:void paint(juce::Graphics&) override;
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.h:27:SpectralCanvasProAudioProcessor& audioProcessor;
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.h:33:JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(SpectralCanvasProEditor)
C:\spectralCanvas Pro\MinimalTest.cpp:2:#include <juce_audio_plugin_client/juce_audio_plugin_client.h>
C:\spectralCanvas Pro\MinimalTest.cpp:4:class MinimalTestEditor : public juce::AudioProcessorEditor
C:\spectralCanvas Pro\MinimalTest.cpp:12:void paint(juce::Graphics& g) override
C:\spectralCanvas Pro\MinimalTest.cpp:14:g.fillAll(juce::Colours::black);
C:\spectralCanvas Pro\MinimalTest.cpp:15:g.setColour(juce::Colours::white);
C:\spectralCanvas Pro\MinimalTest.cpp:16:g.drawFittedText("Minimal Test Plugin", getLocalBounds(), juce::Justification::centred, 1);
C:\spectralCanvas Pro\MinimalTest.cpp:23:JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(MinimalTestEditor)
C:\spectralCanvas Pro\MinimalTest.cpp:28:.withInput("Input", juce::AudioChannelSet::stereo(), true)
C:\spectralCanvas Pro\MinimalTest.cpp:29:.withOutput("Output", juce::AudioChannelSet::stereo(), true))
C:\spectralCanvas Pro\MinimalTest.cpp:39:juce::ignoreUnused(sampleRate, samplesPerBlock);
C:\spectralCanvas Pro\MinimalTest.cpp:46:void MinimalTestProcessor::processBlock(juce::AudioBuffer<float>& buffer, juce::MidiBuffer& midiMessages)
C:\spectralCanvas Pro\MinimalTest.cpp:48:juce::ignoreUnused(midiMessages);
C:\spectralCanvas Pro\MinimalTest.cpp:49:juce::ScopedNoDenormals noDenormals;
C:\spectralCanvas Pro\MinimalTest.cpp:52:auto totalNumInputChannels = getTotalNumInputChannels();
C:\spectralCanvas Pro\MinimalTest.cpp:53:auto totalNumOutputChannels = getTotalNumOutputChannels();
C:\spectralCanvas Pro\MinimalTest.cpp:55:for (auto i = totalNumInputChannels; i < totalNumOutputChannels; ++i)
C:\spectralCanvas Pro\MinimalTest.cpp:59:juce::AudioProcessorEditor* MinimalTestProcessor::createEditor()
C:\spectralCanvas Pro\MinimalTest.cpp:64:void MinimalTestProcessor::getStateInformation(juce::MemoryBlock& destData)
C:\spectralCanvas Pro\MinimalTest.cpp:66:juce::ignoreUnused(destData);
C:\spectralCanvas Pro\MinimalTest.cpp:71:juce::ignoreUnused(data, sizeInBytes);
C:\spectralCanvas Pro\MinimalTest.cpp:75:juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
C:\spectralCanvas Pro\MinimalTest.h:2:#include <juce_audio_processors/juce_audio_processors.h>
C:\spectralCanvas Pro\MinimalTest.h:4:class MinimalTestProcessor : public juce::AudioProcessor
C:\spectralCanvas Pro\MinimalTest.h:12:void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) noexcept override;
C:\spectralCanvas Pro\MinimalTest.h:14:juce::AudioProcessorEditor* createEditor() override;
C:\spectralCanvas Pro\MinimalTest.h:17:const juce::String getName() const override { return "MinimalTest"; }
C:\spectralCanvas Pro\MinimalTest.h:25:void setCurrentProgram(int index) override { juce::ignoreUnused(index); }
C:\spectralCanvas Pro\MinimalTest.h:26:const juce::String getProgramName(int index) override { juce::ignoreUnused(index); return {}; }
C:\spectralCanvas Pro\MinimalTest.h:27:void changeProgramName(int index, const juce::String& newName) override { juce::ignoreUnused(index, newName); }
C:\spectralCanvas Pro\MinimalTest.h:29:void getStateInformation(juce::MemoryBlock& destData) override;
C:\spectralCanvas Pro\MinimalTest.h:33:JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(MinimalTestProcessor)
C:\spectralCanvas Pro\test_processor.cpp:2:#include "Source/SpectralCanvasProAudioProcessor.h"
C:\spectralCanvas Pro\test_processor.cpp:6:std::cout << "Testing SpectralCanvas Pro processor initialization..." << std::endl;
C:\spectralCanvas Pro\test_processor.cpp:10:auto processor = std::make_unique<SpectralCanvasProAudioProcessor>();
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:28:int queueDepthAudioToUI = 0;          // Spectral data queue depth
C:\spectralCanvas Pro\Source\Core\ContinuousVerification.h:31:int dropCountAudioToUI = 0;           // Dropped spectral frames
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:85:// Spectral data frame for Audio Thread → UI Thread communication
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:86:struct SpectralFrame
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:91:alignas(32) float magnitude[NUM_BINS];    // Spectral magnitudes
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:92:alignas(32) float phase[NUM_BINS];        // Spectral phases
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:97:float spectralCentroid;                   // Brightness measure
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:99:SpectralFrame() noexcept
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:106:spectralCentroid = 0.0f;
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:165:UpdateSpectralTexture = 0,
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:176:SpectralFrame spectralData;           // For spectral texture updates
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:186:RenderCommand() noexcept : commandType(UpdateSpectralTexture), sequenceNumber(0) {}
C:\spectralCanvas Pro\Source\Core\MessageBus_Old.h:190:using SpectralDataQueue = SPSCQueue<SpectralFrame, 16>;      // Audio → UI
C:\spectralCanvas Pro\Source\Core\MessageBus.h:98:// Spectral data frame for Audio Thread → UI Thread communication
C:\spectralCanvas Pro\Source\Core\MessageBus.h:104:struct SpectralFrame
C:\spectralCanvas Pro\Source\Core\MessageBus.h:109:alignas(32) float magnitude[NUM_BINS];    // Spectral magnitudes
C:\spectralCanvas Pro\Source\Core\MessageBus.h:110:alignas(32) float phase[NUM_BINS];        // Spectral phases
C:\spectralCanvas Pro\Source\Core\MessageBus.h:117:float spectralCentroid;                   // Brightness measure
C:\spectralCanvas Pro\Source\Core\MessageBus.h:119:SpectralFrame() noexcept
C:\spectralCanvas Pro\Source\Core\MessageBus.h:128:spectralCentroid = 0.0f;
C:\spectralCanvas Pro\Source\Core\MessageBus.h:155:// MaskColumn for GPU → Audio Thread communication
C:\spectralCanvas Pro\Source\Core\MessageBus.h:161:struct MaskColumn
C:\spectralCanvas Pro\Source\Core\MessageBus.h:174:MaskColumn() noexcept
C:\spectralCanvas Pro\Source\Core\MessageBus.h:193:// DIAGNOSTIC: Static asserts to freeze MaskColumn layout and detect instance mismatch
C:\spectralCanvas Pro\Source\Core\MessageBus.h:194:static_assert(std::is_trivially_copyable_v<MaskColumn>, "MaskColumn must be POD for queue safety");
C:\spectralCanvas Pro\Source\Core\MessageBus.h:195:static_assert(alignof(MaskColumn) == 32, "MaskColumn alignment changed - potential cache issues");
C:\spectralCanvas Pro\Source\Core\MessageBus.h:196:static_assert(offsetof(MaskColumn, values) == 0, "values array must be at offset 0");
C:\spectralCanvas Pro\Source\Core\MessageBus.h:204:using SpectralDataQueue = SpscRing<SpectralFrame, 16>;      // Audio → UI
C:\spectralCanvas Pro\Source\Core\MessageBus.h:206:using MaskColumnQueue = SpscRing<MaskColumn, 8>;            // GPU → Audio
C:\spectralCanvas Pro\Source\Core\PaintQueue.h:25:float nx;        // 0..1 normalized X (canvas space)
C:\spectralCanvas Pro\Source\Core\PaintQueue.h:179:using SpectralPaintQueue = PaintQueue<PaintEvent, 4096>;    // UI → Audio paint events
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:17:uint8_t audioPath;                    // AudioPath enum (0=Silent, 1=TestFeeder, 2=Phase4Synth, 3=SpectralEngine)
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:19:bool useFullSpectralEngine;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:23:float spectralGain;                   // 0..2 (needs ramping)
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:24:float spectralMix;                    // 0..1 (needs ramping)
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:70:bool fastPaintMode;                   // Low-latency mode
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:86:useFullSpectralEngine = false;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:89:spectralGain = 1.0f;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:90:spectralMix = 1.0f;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:129:fastPaintMode = false;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:163:spectralGain.setTargetValue(1.0f);
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:164:spectralGain.reset(sampleRate, rampTimeMs / 1000.0f);
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:166:spectralMix.setTargetValue(1.0f);
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:167:spectralMix.reset(sampleRate, rampTimeMs / 1000.0f);
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:182:spectralGain.setCurrentAndTargetValue(1.0f);
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:183:spectralMix.setCurrentAndTargetValue(1.0f);
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:197:spectralGain.setTargetValue(snapshot.spectralGain);
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:198:spectralMix.setTargetValue(snapshot.spectralMix);
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:206:float getSpectralGain() noexcept { return spectralGain.getNextValue(); }
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:207:float getSpectralMix() noexcept { return spectralMix.getNextValue(); }
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:216:spectralGain.skip(numSamples);
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:217:spectralMix.skip(numSamples);
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:226:juce::SmoothedValue<float> spectralGain;
C:\spectralCanvas Pro\Source\Core\ParameterSnapshot.h:227:juce::SmoothedValue<float> spectralMix;
C:\spectralCanvas Pro\Source\Core\Params.h:30:// Spectral Processing Parameters
C:\spectralCanvas Pro\Source\Core\Params.h:31:const juce::String spectralGain = "spectral_gain";
C:\spectralCanvas Pro\Source\Core\Params.h:32:const juce::String spectralMix = "spectral_mix";
C:\spectralCanvas Pro\Source\Core\Params.h:53:const juce::String fastPaintMode = "fast_paint_mode"; // Low-latency mode for interaction
C:\spectralCanvas Pro\Source\Core\Params.h:110:// Spectral Processing
C:\spectralCanvas Pro\Source\Core\Params.h:111:const juce::NormalisableRange<float> spectralGainRange(0.0f, 2.0f, 0.01f);
C:\spectralCanvas Pro\Source\Core\Params.h:112:const float spectralGainDefault = 1.0f;
C:\spectralCanvas Pro\Source\Core\Params.h:114:const juce::NormalisableRange<float> spectralMixRange(0.0f, 1.0f, 0.01f);
C:\spectralCanvas Pro\Source\Core\Params.h:115:const float spectralMixDefault = 1.0f;
C:\spectralCanvas Pro\Source\Core\Params.h:221:// Spectral Processing Parameters
C:\spectralCanvas Pro\Source\Core\Params.h:223:ParameterIDs::spectralGain, "Spectral Gain",
C:\spectralCanvas Pro\Source\Core\Params.h:224:ParameterRanges::spectralGainRange, ParameterRanges::spectralGainDefault));
C:\spectralCanvas Pro\Source\Core\Params.h:227:ParameterIDs::spectralMix, "Spectral Mix",
C:\spectralCanvas Pro\Source\Core\Params.h:228:ParameterRanges::spectralMixRange, ParameterRanges::spectralMixDefault));
C:\spectralCanvas Pro\Source\Core\Params.h:267:ParameterIDs::fastPaintMode, "Fast Paint Mode", false));
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:4:void SpectralCanvasProAudioProcessor::processBlock(juce::AudioBuffer<float>& buffer,
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:64:void SpectralCanvasProAudioProcessor::updateTimebase() noexcept
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:85:void SpectralCanvasProAudioProcessor::buildParameterSnapshot() noexcept
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:92:auto* spectralGainParam = apvts.getRawParameterValue(Params::ParameterIDs::spectralGain);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:93:auto* spectralMixParam = apvts.getRawParameterValue(Params::ParameterIDs::spectralMix);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:101:currentSnapshot.spectralGain = spectralGainParam ? spectralGainParam->load() : 1.0f;
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:102:currentSnapshot.spectralMix = spectralMixParam ? spectralMixParam->load() : 1.0f;
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:113:if (useFullSpectralEngine_.load(std::memory_order_relaxed))
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:114:currentSnapshot.audioPath = static_cast<uint8_t>(AudioPath::SpectralEngine);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:122:void SpectralCanvasProAudioProcessor::processQueuedCommands() noexcept
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:140:std::optional<MaskColumn> maskUpdate;
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:141:while ((maskUpdate = maskColumnQueue.pop()).has_value())
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:148:coreEngine->applyMaskColumn(mask.values, mask.numBins, mask.engineFrameId);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:154:void SpectralCanvasProAudioProcessor::setProcessing(bool isNowPlaying)
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:164:if (spectralEngine) spectralEngine->reset();
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:167:spectralDataQueue.clear();
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:169:maskColumnQueue.clear();
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:177:void SpectralCanvasProAudioProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:191:coreEngine = std::make_unique<SpectralCoreEngine>();
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:207:if (!spectralEngine)
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:209:spectralEngine = std::make_unique<SpectralEngine>();
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:210:spectralEngine->initialize(sampleRate, samplesPerBlock);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:214:spectralStub.prepare(sampleRate, 512, 257, getTotalNumOutputChannels());
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:219:void SpectralCanvasProAudioProcessor::applyParameterUpdate(const ParameterUpdate& update) noexcept
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:233:void SpectralCanvasProAudioProcessor::processLegacyPath(juce::AudioBuffer<float>& buffer, int numSamples) noexcept
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:252:spectralStub.popAllMaskColumnsInto(maskColumnQueue);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:253:spectralStub.process(buffer, oscGain_.load(std::memory_order_relaxed));
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:257:case AudioPath::SpectralEngine:
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:258:// Use full spectral engine
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:259:if (spectralEngine && spectralEngine->isInitialized())
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:261:spectralEngine->processBlock(
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:274:void SpectralCanvasProAudioProcessor::publishTelemetry(const SpectralCoreEngine::EngineStateSnapshot& snapshot) noexcept
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:276:// Create spectral frame for UI
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:277:SpectralFrame frame;
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:282:frame.spectralCentroid = snapshot.spectralCentroid;
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:284:// Extract spectral data from engine
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:287:coreEngine->extractSpectralData(frame.magnitude, frame.phase, SpectralFrame::NUM_BINS);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:291:spectralDataQueue.push(frame);
C:\spectralCanvas Pro\Source\Core\ProcessBlockImpl.cpp:295:void SpectralCanvasProAudioProcessor::generateTestTone(juce::AudioBuffer<float>& buffer, int numSamples) noexcept
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:13:* SpectralCoreEngine - Pure DSP engine with no JUCE dependencies
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:19:class SpectralCoreEngine
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:30:float peakMagnitude;                  // Current spectral peak
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:31:float spectralCentroid;               // Brightness measure
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:32:uint32_t maskColumnsProcessed;        // Paint events applied
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:33:uint32_t maskColumnsDropped;          // Paint events dropped
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:65:SpectralCoreEngine() noexcept;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:66:~SpectralCoreEngine() noexcept;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:69:SpectralCoreEngine(const SpectralCoreEngine&) = delete;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:70:SpectralCoreEngine& operator=(const SpectralCoreEngine&) = delete;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:84:// Spectral data extraction (RT-safe)
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:85:bool extractSpectralData(float* magnitudes, float* phases, int maxBins) noexcept;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:93:void applyMaskColumn(const float* maskValues, uint32_t numBins,
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:116:void performSpectralProcessing(const ParameterSnapshot& params) noexcept;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:154:mutable std::atomic<float> spectralCentroid_{0.0f};
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:155:mutable std::atomic<uint32_t> maskColumnsProcessed_{0};
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:156:mutable std::atomic<uint32_t> maskColumnsDropped_{0};
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:160:void resetSpectralState() noexcept;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:161:void updateSpectralFeatures() noexcept;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:205:namespace SpectralCoreOps
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:207:// Pure spectral processing functions
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:210:void applySpectralMask(float* magnitudes, const float* mask, int numBins, float depth) noexcept;
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:214:// Spectral analysis functions
C:\spectralCanvas Pro\Source\Core\SpectralCoreEngine.h:215:float computeSpectralCentroid(const float* magnitudes, int numBins, float binFreq) noexcept;
C:\spectralCanvas Pro\Source\DSP\MaskTestFeeder.cpp:14:numBins_ = std::min(numBins, static_cast<size_t>(MaskColumn::MAX_BINS));
C:\spectralCanvas Pro\Source\DSP\MaskTestFeeder.cpp:56:bool MaskTestFeeder::tryPopMask(MaskColumn& mask) noexcept
C:\spectralCanvas Pro\Source\DSP\MaskTestFeeder.cpp:118:for (size_t bin = numBins_; bin < MaskColumn::MAX_BINS; ++bin)
C:\spectralCanvas Pro\Source\DSP\MaskTestFeeder.cpp:124:bool MaskTestFeeder::tryPushMask(const MaskColumn& mask) noexcept
C:\spectralCanvas Pro\Source\DSP\MaskTestFeeder.h:8:* RT-safe test harness for validating MaskColumn → SpectralEngine → audio output
C:\spectralCanvas Pro\Source\DSP\MaskTestFeeder.h:35:bool tryPopMask(MaskColumn& mask) noexcept;
C:\spectralCanvas Pro\Source\DSP\MaskTestFeeder.h:44:std::array<MaskColumn, NUM_TEST_PATTERNS> testPatterns_;
C:\spectralCanvas Pro\Source\DSP\MaskTestFeeder.h:47:std::array<MaskColumn, RING_CAPACITY> ringBuffer_;
C:\spectralCanvas Pro\Source\DSP\MaskTestFeeder.h:63:bool tryPushMask(const MaskColumn& mask) noexcept;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:8:, numSpectralFrames_(0)
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:32:// Pre-allocate spectral frame storage
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:33:spectralFrames_ = std::make_unique<SpectralFrameData[]>(MAX_SAMPLE_FRAMES);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:43:numSpectralFrames_.store(0, std::memory_order_release);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:183:sampleInfo_.numSpectralFrames = numSpectralFrames_.load();
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:187:juce::String(numSpectralFrames_.load()) + " spectral frames generated");
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:220:auto& magnitude = spectralFrames_[frameIndex].magnitude.get();
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:221:auto& phase = spectralFrames_[frameIndex].phase.get();
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:238:numSpectralFrames_.store(startFrame + frameCount, std::memory_order_release);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:290:bool SampleLoader::getSpectralFrame(size_t frameIndex, float* magnitudeOut, float* phaseOut) const noexcept
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:292:if (!hasSample() || frameIndex >= numSpectralFrames_.load(std::memory_order_acquire))
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:295:const auto& frame = spectralFrames_[frameIndex];
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:302:void SampleLoader::getSpectralFrameInterpolated(double framePosition, float* magnitudeOut, float* phaseOut) const noexcept
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:311:const size_t numFrames = numSpectralFrames_.load(std::memory_order_acquire);
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:326:const auto& frameData0 = spectralFrames_[frame0];
C:\spectralCanvas Pro\Source\DSP\SampleLoader.cpp:327:const auto& frameData1 = spectralFrames_[frame1];
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:12:* Loads audio files and preprocesses them into spectral frames for RT-safe access
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:20:static constexpr size_t MAX_SAMPLE_FRAMES = 8192; // Max spectral frames per sample
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:37:size_t getNumSpectralFrames() const noexcept { return numSpectralFrames_.load(std::memory_order_acquire); }
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:41:// RT-safe spectral frame access (audio thread only)
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:42:bool getSpectralFrame(size_t frameIndex, float* magnitudeOut, float* phaseOut) const noexcept;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:43:void getSpectralFrameInterpolated(double framePosition, float* magnitudeOut, float* phaseOut) const noexcept;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:56:size_t numSpectralFrames = 0;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:63:// Pre-allocated spectral frame storage
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:64:struct SpectralFrameData
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:69:SpectralFrameData() noexcept = default;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:72:// Pre-allocated array of spectral frames
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:73:std::unique_ptr<SpectralFrameData[]> spectralFrames_;
C:\spectralCanvas Pro\Source\DSP\SampleLoader.h:87:std::atomic<size_t> numSpectralFrames_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:1:#include "SpectralEngine_Fixed.h"
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:9:SpectralEngine::SpectralEngine() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:13:, spectralGain_(1.0f)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:14:, spectralMix_(1.0f)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:17:, spectralCentroid_(0.0f)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:38:SpectralEngine::~SpectralEngine() noexcept = default;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:40:void SpectralEngine::initialize(double sampleRate, int maxBlockSize)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:59:void SpectralEngine::reset() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:84:void SpectralEngine::processBlock(const float* inputBuffer, float* outputBuffer, int numSamples) noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:93:// Simple pass-through for now with basic spectral analysis
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:99:// Store input data for spectral analysis
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:112:// Trigger spectral analysis every HOP_SIZE samples
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:117:updateSpectralFeatures();
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:126:void SpectralEngine::performSTFT() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:170:void SpectralEngine::updateSpectralFeatures() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:172:// Calculate spectral centroid
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:188:spectralCentroid_.store(centroid, std::memory_order_relaxed);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:209:void SpectralEngine::performiFFT() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:214:void SpectralEngine::applySpectralProcessing() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:216:const float gain = spectralGain_.load(std::memory_order_relaxed);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:228:bool SpectralEngine::extractSpectralFrame(SpectralFrame& frame) noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:233:// Copy current spectral data
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.cpp:241:frame.spectralCentroid = spectralCentroid_.load(std::memory_order_relaxed);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:9:class SpectralEngine
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:16:SpectralEngine() noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:17:~SpectralEngine() noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:20:SpectralEngine(const SpectralEngine&) = delete;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:21:SpectralEngine& operator=(const SpectralEngine&) = delete;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:30:// RT-safe spectral data extraction (audio thread only)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:31:bool extractSpectralFrame(SpectralFrame& frame) noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:34:void setSpectralGain(float gain) noexcept { spectralGain_.store(gain, std::memory_order_relaxed); }
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:35:void setSpectralMix(float mix) noexcept { spectralMix_.store(mix, std::memory_order_relaxed); }
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:45:void updateSpectralFeatures() noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:46:void applySpectralProcessing() noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:54:// Spectral data (magnitude and phase)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:79:std::atomic<float> spectralGain_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:80:std::atomic<float> spectralMix_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:86:// Spectral analysis
C:\spectralCanvas Pro\Source\DSP\SpectralEngine_Fixed.h:87:std::atomic<float> spectralCentroid_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:1:#include "SpectralEngine.h"
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:5:SpectralEngine::SpectralEngine() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:10:, spectralGain_(1.0f)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:11:, spectralMix_(1.0f)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:14:, spectralCentroid_(0.0f)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:17:RT_SAFE_LOG("SpectralEngine constructor called");
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:20:SpectralEngine::~SpectralEngine() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:22:RT_SAFE_LOG("SpectralEngine destructor called");
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:25:void SpectralEngine::initialize(double sampleRate, int maxBlockSize)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:27:RT_SAFE_LOG("Initializing SpectralEngine with sample rate: " + juce::String(sampleRate));
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:55:RT_SAFE_LOG("SpectralEngine initialization complete");
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:58:void SpectralEngine::reset() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:60:RT_SAFE_LOG("Resetting SpectralEngine");
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:77:void SpectralEngine::processBlock(const float* inputBuffer, float* outputBuffer, int numSamples) noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:114:applySpectralProcessing();
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:134:void SpectralEngine::performSTFT() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:177:// Update spectral features
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:178:updateSpectralFeatures();
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:181:void SpectralEngine::updateSpectralFeatures() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:183:// Calculate spectral centroid
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:199:spectralCentroid_.store(centroid, std::memory_order_relaxed);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:220:void SpectralEngine::applySpectralProcessing() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:222:const float gain = spectralGain_.load(std::memory_order_relaxed);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:248:const float mix = std::clamp(spectralMix_.load(std::memory_order_relaxed), 0.0f, 1.0f);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:283:void SpectralEngine::performiFFT() noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:340:bool SpectralEngine::extractSpectralFrame(SpectralFrame& frame) noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:345:// Copy current spectral data
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:353:frame.spectralCentroid = spectralCentroid_.load(std::memory_order_relaxed);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:358:void SpectralEngine::updateCurrentMask(const MaskColumn* maskColumn) noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:360:if (maskColumn == nullptr || maskColumn->numBins == 0)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:368:currentMask_.store(maskColumn->values, std::memory_order_release);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:372:void SpectralEngine::updateCurrentMask(const float* maskPtr, int numBins) noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:387:void SpectralEngine::applyMaskColumn(const MaskColumn& maskColumn) noexcept
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:390:const size_t maskBins = std::min(static_cast<size_t>(maskColumn.numBins), NUM_BINS);
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.cpp:431:const float maskValue = maskColumn.values[bin];
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:11:class SpectralEngine
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:17:Resynth = 1, // Sample-based spectral manipulation
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:26:SpectralEngine() noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:27:~SpectralEngine() noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:30:SpectralEngine(const SpectralEngine&) = delete;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:31:SpectralEngine& operator=(const SpectralEngine&) = delete;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:40:// RT-safe spectral data extraction (audio thread only)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:41:bool extractSpectralFrame(SpectralFrame& frame) noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:44:void setSpectralGain(float gain) noexcept { spectralGain_.store(gain, std::memory_order_relaxed); }
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:45:void setSpectralMix(float mix) noexcept { spectralMix_.store(mix, std::memory_order_relaxed); }
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:53:void updateCurrentMask(const MaskColumn* maskColumn) noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:55:void applyMaskColumn(const MaskColumn& maskColumn) noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:65:void updateSpectralFeatures() noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:66:void applySpectralProcessing() noexcept;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:74:// Spectral data (magnitude and phase)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:100:std::atomic<float> spectralGain_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:101:std::atomic<float> spectralMix_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:108:// Current mask for spectral painting (RT-safe atomic pointer)
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:109:std::atomic<const float*> currentMask_; // Points to MaskColumn::values
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:115:// Spectral analysis
C:\spectralCanvas Pro\Source\DSP\SpectralEngine.h:116:std::atomic<float> spectralCentroid_;
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:1:#include "SpectralEngineStub.h"
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:7:void SpectralEngineStub::prepare(double sampleRate, int fftSize, int numBins, int channels) {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:28:void SpectralEngineStub::reset() {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:44:void SpectralEngineStub::setStride(int stride) {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:48:void SpectralEngineStub::popAllMaskColumnsInto(MaskColumnQueue& queue) noexcept {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:54:// Drain all available MaskColumns from queue (non-blocking)
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:55:std::optional<MaskColumn> columnOpt;
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:60:const MaskColumn& column = *columnOpt;
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:111:"SpectralEngineStub: gotAny=%s, totalPops=%llu, receivedMag=%.6f, actualMag=%.6f",
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:117:void SpectralEngineStub::process(juce::AudioBuffer<float>& outBuffer, float oscGain) noexcept {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:128:"SpectralEngineStub::process: oscGain=%.3f, activeBins=%d",
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:149:"SpectralEngineStub: activeBins=%d, maxMag=%.6f, oscGain=%.3f",
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:218:int SpectralEngineStub::calculateStride(int activeBinCount) const noexcept {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:225:void SpectralEngineStub::smoothMagnitudes() noexcept {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:236:// NOTE: magnitudes_[k] NOT cleared here - will be cleared at start of popAllMaskColumnsInto for proper accumulation
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:240:int SpectralEngineStub::countActiveBins() const noexcept {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.cpp:252:void SpectralEngineStub::renderBinAdd(juce::AudioBuffer<float>& outBuffer, int bin, float amplitude) noexcept {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.h:9:class SpectralEngineStub {
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.h:11:SpectralEngineStub() = default;
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.h:12:~SpectralEngineStub() = default;
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.h:26:// Called on audio thread before process - drain MaskColumn queue
C:\spectralCanvas Pro\Source\DSP\SpectralEngineStub.h:27:void popAllMaskColumnsInto(MaskColumnQueue& queue) noexcept;
C:\spectralCanvas Pro\Source\DSP\SynthEngine.h:44:// Get current spectral data for visualization
C:\spectralCanvas Pro\Source\DSP\SynthEngine.h:45:void getSpectralMagnitudes(float* magnitudes, size_t numBins) const noexcept;
C:\spectralCanvas Pro\Source\DSP\SynthEngine.h:99:std::atomic<float> brightness_{0.5f};       // Spectral centroid control
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:2:#include "CanvasComponent.h"
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:4:BottomBar::BottomBar(SpectralCanvasProAudioProcessor& processor, CanvasComponent& canvas)
C:\spectralCanvas Pro\Source\GUI\BottomBar.cpp:5:: audioProcessor(processor), canvasComponent(canvas)
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:4:#include "../SpectralCanvasProAudioProcessor.h"
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:6:class CanvasComponent;
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:9:* Floating control strip at bottom of canvas with transport and metrics
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:17:BottomBar(SpectralCanvasProAudioProcessor& processor, CanvasComponent& canvas);
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:27:// Update performance metrics from canvas
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:36:SpectralCanvasProAudioProcessor& audioProcessor;
C:\spectralCanvas Pro\Source\GUI\BottomBar.h:37:CanvasComponent& canvasComponent;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:1:#include "CanvasComponent.h"
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:6:CanvasComponent::CanvasComponent(SpectralCanvasProAudioProcessor& processor)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:10:juce::Logger::writeToLog("CanvasComponent constructor started");
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:22:juce::Logger::writeToLog("CanvasComponent constructor completed");
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:29:CanvasComponent::~CanvasComponent()
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:36:void CanvasComponent::paint(juce::Graphics& g)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:69:void CanvasComponent::paintSoftwareFallback(juce::Graphics& g)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:89:// Add animated spectral bars (if we have spectral data)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:90:auto& spectralQueue = audioProcessor.getSpectralDataQueue();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:91:if (spectralQueue.hasDataAvailable())
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:93:// Process latest spectral frame
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:94:while (auto frame = spectralQueue.pop())
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:96:// Draw spectral bins as nebula texture
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:97:const int numBins = SpectralFrame::NUM_BINS;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:173:void CanvasComponent::resized()
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:176:// Canvas fills entire area, top strip handled by parent editor
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:179:void CanvasComponent::mouseDown(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:199:point.spectralPos = screenToSpectral(e.position);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:211:void CanvasComponent::mouseDrag(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:218:point.spectralPos = screenToSpectral(e.position);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:224:// METASYNTH-STYLE: Generate immediate spectral feedback
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:241:void CanvasComponent::mouseUp(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:267:void CanvasComponent::mouseMove(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:273:void CanvasComponent::mouseWheelMove(const juce::MouseEvent& e, const juce::MouseWheelDetails& wheel)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:290:bool CanvasComponent::isInterestedInFileDrag(const juce::StringArray& files)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:305:void CanvasComponent::fileDragEnter(const juce::StringArray& files, int x, int y)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:312:void CanvasComponent::fileDragExit(const juce::StringArray& files)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:319:void CanvasComponent::filesDropped(const juce::StringArray& files, int x, int y)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:344:void CanvasComponent::timerCallback()
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:346:processSpectralData();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:352:void CanvasComponent::setEngineMode(int mode) { /* TODO: Implement */ }
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:353:void CanvasComponent::setBlendAmount(float blend) { /* TODO: Implement */ }
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:354:void CanvasComponent::setBrushType(int type) { currentBrushType = type; }
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:355:void CanvasComponent::setBrushSize(float size) { currentBrushSize = size; }
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:356:void CanvasComponent::setBrushStrength(float strength) { currentBrushStrength = strength; }
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:357:void CanvasComponent::setGridVisible(bool visible) { gridVisible = visible; repaint(); }
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:358:void CanvasComponent::setSnapToScale(bool snap) { snapToScale = snap; }
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:362:juce::Point<float> CanvasComponent::screenToSpectral(juce::Point<float> screenPos) const
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:364:const float canvasHeight = (float)getHeight();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:365:const float canvasWidth = (float)getWidth();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:370:const float usableHeight = canvasHeight - topMargin - bottomMargin;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:372:float u = screenPos.x / canvasWidth;                           // Time: 0..1 (left to right)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:379:juce::Point<float> CanvasComponent::spectralToScreen(juce::Point<float> spectralPos) const
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:381:const float canvasHeight = (float)getHeight();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:382:const float canvasWidth = (float)getWidth();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:386:const float usableHeight = canvasHeight - topMargin - bottomMargin;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:388:float x = spectralPos.x * canvasWidth;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:389:float y = topMargin + (1.0f - spectralPos.y) * usableHeight;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:394:void CanvasComponent::sendGestureToProcessor(const PaintStroke& stroke)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:402:void CanvasComponent::processSpectralData()
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:404:// Process any pending spectral frames from audio thread
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:405:auto& spectralQueue = audioProcessor.getSpectralDataQueue();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:406:while (auto frame = spectralQueue.pop())
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:410:gpuRenderer->updateSpectralTexture(*frame);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:415:void CanvasComponent::updatePerformanceMetrics()
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:435:void CanvasComponent::drawGridOverlay(juce::Graphics& g)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:482:void CanvasComponent::drawBrushCursor(juce::Graphics& g)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:505:juce::Colour CanvasComponent::getNebulaAccentColor() const
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:510:void CanvasComponent::generateImmediateAudioFeedback(const PaintStroke::Point& point)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:512:// MetaSynth-style: Convert paint stroke directly to spectral mask
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:513:// spectralPos.y = frequency (0-1), spectralPos.x = time position
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:515:MaskColumn maskColumn;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:516:maskColumn.numBins = 257; // For 512-point FFT (NUM_BINS = 257)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:517:maskColumn.timestampSamples = audioProcessor.getSampleRate() * point.timestamp;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:518:maskColumn.frameIndex = static_cast<uint32_t>(point.timestamp * 60.0); // ~60fps equivalent
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:521:for (size_t i = 0; i < maskColumn.numBins; ++i)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:523:maskColumn.values[i] = 1.0f; // No masking by default
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:527:const float frequencyRatio = juce::jlimit(0.0f, 1.0f, point.spectralPos.y);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:528:const int centerBin = static_cast<int>(frequencyRatio * (maskColumn.numBins - 1));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:534:bin <= juce::jmin(static_cast<int>(maskColumn.numBins - 1), centerBin + brushRadius);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:542:case 0: // Paint - Add spectral energy
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:543:maskColumn.values[bin] = juce::jlimit(0.0f, 3.0f,
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:544:maskColumn.values[bin] + (currentBrushStrength * falloff * point.pressure));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:548:maskColumn.values[bin] = (falloff > 0.5f) ? 2.0f : 1.0f;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:551:case 2: // Erase - Remove spectral energy
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:552:maskColumn.values[bin] = juce::jmax(0.0f,
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:553:maskColumn.values[bin] - (currentBrushStrength * falloff * point.pressure));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:559:maskColumn.values[bin] = 2.0f * currentBrushStrength;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:566:if (auto& maskQueue = audioProcessor.getMaskColumnQueue(); maskQueue.hasSpaceAvailable())
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:568:maskQueue.push(maskColumn);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:572:void CanvasComponent::parentHierarchyChanged()
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Backup.cpp:577:void CanvasComponent::visibilityChanged()
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:1:#include "CanvasComponent.h"
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:4:CanvasComponent::CanvasComponent(SpectralCanvasProAudioProcessor& processor)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:15:CanvasComponent::~CanvasComponent() = default;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:17:void CanvasComponent::paint(juce::Graphics& g)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:43:void CanvasComponent::resized()
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:48:void CanvasComponent::mouseDown(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:70:point.spectralPos = screenToSpectral(e.position);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:80:void CanvasComponent::mouseDrag(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:89:point.spectralPos = screenToSpectral(e.position);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:104:void CanvasComponent::mouseUp(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:126:void CanvasComponent::mouseMove(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:132:void CanvasComponent::mouseWheelMove(const juce::MouseEvent& e, const juce::MouseWheelDetails& wheel)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:147:bool CanvasComponent::isInterestedInFileDrag(const juce::StringArray& files)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:157:void CanvasComponent::fileDragEnter(const juce::StringArray&, int, int)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:163:void CanvasComponent::fileDragExit(const juce::StringArray&)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:169:void CanvasComponent::filesDropped(const juce::StringArray& files, int, int)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:179:void CanvasComponent::timerCallback()
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:185:void CanvasComponent::setEngineMode(int) { }
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:186:void CanvasComponent::setBlendAmount(float) { }
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:187:void CanvasComponent::setBrushType(int type) { currentBrushType = type; }
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:188:void CanvasComponent::setBrushSize(float size) { currentBrushSize = size; }
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:189:void CanvasComponent::setBrushStrength(float strength) { currentBrushStrength = strength; }
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:190:void CanvasComponent::setGridVisible(bool visible) { gridVisible = visible; repaint(); }
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:191:void CanvasComponent::setSnapToScale(bool snap) { snapToScale = snap; }
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:194:juce::Point<float> CanvasComponent::screenToSpectral(juce::Point<float> screenPos) const
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:196:const float canvasHeight = (float)getHeight();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:197:const float canvasWidth = (float)getWidth();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:199:float u = screenPos.x / canvasWidth;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:200:float v = 1.0f - (screenPos.y / canvasHeight);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:206:juce::Point<float> CanvasComponent::spectralToScreen(juce::Point<float> spectralPos) const
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:208:const float canvasHeight = (float)getHeight();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:209:const float canvasWidth = (float)getWidth();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:211:float x = spectralPos.x * canvasWidth;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:212:float y = (1.0f - spectralPos.y) * canvasHeight;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:217:void CanvasComponent::parentHierarchyChanged()
C:\spectralCanvas Pro\Source\GUI\CanvasComponent_Minimal.cpp:222:void CanvasComponent::visibilityChanged()
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:1:#include "CanvasComponent.h"
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:11:CanvasComponent::CanvasComponent(SpectralCanvasProAudioProcessor& processor)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:29:CanvasComponent::~CanvasComponent() = default;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:31:void CanvasComponent::paint(juce::Graphics& g)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:67:case SpectralCanvasProAudioProcessor::AudioPath::TestFeeder:
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:70:case SpectralCanvasProAudioProcessor::AudioPath::Phase4Synth:
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:108:case SpectralCanvasProAudioProcessor::AudioPath::Silent:
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:116:// Panel background so text never overlaps the canvas
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:157:void CanvasComponent::resized()
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:162:void CanvasComponent::mouseDown(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:187:point.spectralPos = screenToSpectral(e.position);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:197:void CanvasComponent::mouseDrag(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:209:point.spectralPos = screenToSpectral(e.position);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:224:void CanvasComponent::mouseUp(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:246:void CanvasComponent::mouseMove(const juce::MouseEvent& e)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:252:void CanvasComponent::mouseWheelMove(const juce::MouseEvent& e, const juce::MouseWheelDetails& wheel)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:267:bool CanvasComponent::isInterestedInFileDrag(const juce::StringArray& files)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:277:void CanvasComponent::fileDragEnter(const juce::StringArray&, int, int)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:283:void CanvasComponent::fileDragExit(const juce::StringArray&)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:289:void CanvasComponent::filesDropped(const juce::StringArray& files, int, int)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:299:void CanvasComponent::timerCallback()
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:302:// Check if we need to dispatch accumulated MaskColumn - use actual audio path
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:303:if (audioProcessor.getCurrentPath() == SpectralCanvasProAudioProcessor::AudioPath::Phase4Synth && accumulator_.hasData) {
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:308:// Create and send accumulated MaskColumn
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:309:MaskColumn mask;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:335:if (audioProcessor.getCurrentPath() == SpectralCanvasProAudioProcessor::AudioPath::Phase4Synth) {
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:336:audioProcessor.pushMaskColumn(mask);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:350:void CanvasComponent::setEngineMode(int) { }
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:351:void CanvasComponent::setBlendAmount(float) { }
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:352:void CanvasComponent::setBrushType(int type) { currentBrushType = type; }
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:353:void CanvasComponent::setBrushSize(float size) { currentBrushSize = size; }
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:354:void CanvasComponent::setBrushStrength(float strength) { currentBrushStrength = strength; }
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:355:void CanvasComponent::setGridVisible(bool visible) { gridVisible = visible; repaint(); }
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:356:void CanvasComponent::setSnapToScale(bool snap) { snapToScale = snap; }
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:359:juce::Point<float> CanvasComponent::screenToSpectral(juce::Point<float> screenPos) const
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:361:const float canvasHeight = (float)getHeight();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:362:const float canvasWidth = (float)getWidth();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:364:float u = screenPos.x / canvasWidth;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:365:float v = 1.0f - (screenPos.y / canvasHeight);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:371:juce::Point<float> CanvasComponent::spectralToScreen(juce::Point<float> spectralPos) const
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:373:const float canvasHeight = (float)getHeight();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:374:const float canvasWidth = (float)getWidth();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:376:float x = spectralPos.x * canvasWidth;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:377:float y = (1.0f - spectralPos.y) * canvasHeight;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:382:void CanvasComponent::parentHierarchyChanged()
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:387:void CanvasComponent::visibilityChanged()
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:392:void CanvasComponent::createAndSendMaskColumn(juce::Point<float> mousePos)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:394:// Phase 2-3 Validation: Convert mouse position to MaskColumn for latency testing
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:395:MaskColumn mask;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:414:// Convert mouse position to spectral position
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:415:auto spectralPos = screenToSpectral(mousePos);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:420:size_t centerBin = static_cast<size_t>(spectralPos.x * (mask.numBins - 1));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:421:float amplitude = spectralPos.y * currentBrushStrength;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:438:audioProcessor.pushMaskColumn(mask);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:443:inline int CanvasComponent::uiToBinLinear(float yNorm, int numBins) noexcept
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:449:inline int CanvasComponent::uiToBinLog(float yNorm, double sampleRate, int fftSize) noexcept
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:458:void CanvasComponent::createAndSendMaskColumnPhase4(juce::Point<float> mousePos)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:468:// Convert mouse position to spectral coordinates
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:469:const auto spectralPos = screenToSpectral(mousePos);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:470:const float yNorm = spectralPos.y;  // Already normalized by screenToSpectral
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:500:// IMMEDIATE TEST: Also send direct MaskColumn for debugging
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:501:MaskColumn testMask;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:524:audioProcessor.pushMaskColumn(testMask);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:542:void CanvasComponent::pushMaskFromScreenY(float y) noexcept
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:547:// TESTING: Temporarily bypass path check like we did in pushMaskColumn
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:550:if (audioProcessor.getCurrentPath() != SpectralCanvasProAudioProcessor::AudioPath::Phase4Synth)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:569:// Create MaskColumn and push directly to processor
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:570:MaskColumn col;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:582:audioProcessor.pushMaskColumn(col);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:585:auto& q = audioProcessor.getMaskColumnQueue();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:592:juce::Logger::writeToLog("[UI] MaskQueue addr=" + juce::String::toHexString(reinterpret_cast<uintptr_t>(&q)) + " sizeof(MaskColumn)=" + juce::String(sizeof(MaskColumn)));
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:596:bool CanvasComponent::keyPressed(const juce::KeyPress& key)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:600:juce::Logger::writeToLog("*** 'I' KEY PRESSED - INJECTING TEST MASKCOLUMN ***");
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:602:if (audioProcessor.getCurrentPath() == SpectralCanvasProAudioProcessor::AudioPath::Phase4Synth) {
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:603:// Create test MaskColumn with strong 440Hz tone
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:604:MaskColumn testCol;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:611:for (size_t i = 0; i < MaskColumn::MAX_BINS; ++i) {
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.cpp:628:bool success = audioProcessor.pushMaskColumn(testCol);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:4:#include "../SpectralCanvasProAudioProcessor.h"
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:11:* Phase 2-3 Minimal Canvas Component
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:15:* - Simple spectral visualization and paint strokes
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:19:class CanvasComponent : public juce::Component,
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:24:CanvasComponent(SpectralCanvasProAudioProcessor& processor);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:25:~CanvasComponent() override;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:62:SpectralCanvasProAudioProcessor& audioProcessor;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:75:juce::Point<float> spectralPos; // U,V in spectral space (0-1)
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:91:// Canvas state
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:113:juce::Point<float> screenToSpectral(juce::Point<float> screenPos) const;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:114:juce::Point<float> spectralToScreen(juce::Point<float> spectralPos) const;
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:115:void sendMaskColumnToAudio(const PaintStroke::Point& point);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:116:void processSpectralData();
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:121:void createAndSendMaskColumn(juce::Point<float> mousePos);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:128:void createAndSendMaskColumnPhase4(juce::Point<float> mousePos);
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:130:// MaskColumn accumulator for batching
C:\spectralCanvas Pro\Source\GUI\CanvasComponent.h:153:JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(CanvasComponent)
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:2:#include "CanvasComponent.h"
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:4:TopStrip::TopStrip(SpectralCanvasProAudioProcessor& processor, CanvasComponent& canvas)
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:5:: audioProcessor(processor), canvasComponent(canvas)
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:102:fastPaintButton = std::make_unique<juce::ToggleButton>("Fast Paint");
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:103:fastPaintButton->addListener(this);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:104:addAndMakeVisible(*fastPaintButton);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:134:g.drawText("SpectralCanvas Pro v2.0",
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:199:fastPaintButton->setBounds(x, y + 2, 70, 18);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:213:canvasComponent.setSnapToScale(snapToScaleButton->getToggleState());
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:220:else if (button == fastPaintButton.get())
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:224:param->setValueNotifyingHost(fastPaintButton->getToggleState() ? 1.0f : 0.0f);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:234:canvasComponent.setBlendAmount(blendValue);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:244:canvasComponent.setBrushSize(sizeValue);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:254:canvasComponent.setBrushStrength(strengthValue);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:270:canvasComponent.setEngineMode(modeValue);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:286:canvasComponent.setBrushType(brushType);
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:365:juce::String(audioProcessor.getSampleLoader().getNumSpectralFrames()) +
C:\spectralCanvas Pro\Source\GUI\TopStrip.cpp:366:" spectral frames");
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:4:#include "../SpectralCanvasProAudioProcessor.h"
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:6:class CanvasComponent;
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:9:* Floating control strip at top of canvas with Mode/Brush/Blend controls
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:18:TopStrip(SpectralCanvasProAudioProcessor& processor, CanvasComponent& canvas);
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:33:SpectralCanvasProAudioProcessor& audioProcessor;
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:34:CanvasComponent& canvasComponent;
C:\spectralCanvas Pro\Source\GUI\TopStrip.h:57:std::unique_ptr<juce::ToggleButton> fastPaintButton;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:26:if (!createSpectralTexture(spectralWidth_, spectralHeight_))
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:44:spectralSRV_.Reset();
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:45:spectralTexture_.Reset();
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:48:spectralPS_.Reset();
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:183:bool D3D11Renderer::createSpectralTexture(int width, int height)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:185:spectralWidth_ = width;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:186:spectralHeight_ = height;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:199:HRESULT hr = device_->CreateTexture2D(&desc, nullptr, &spectralTexture_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:202:hr = device_->CreateShaderResourceView(spectralTexture_.Get(), nullptr, &spectralSRV_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:217:void D3D11Renderer::updateSpectralTexture(const SpectralFrame& frame)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:219:if (!spectralTexture_) return;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:226:HRESULT hr = context_->Map(spectralTexture_.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &mapped);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:233:for (int y = 0; y < spectralHeight_; ++y)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:235:for (int x = 0; x < spectralWidth_ && x < static_cast<int>(SpectralFrame::NUM_BINS); ++x)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:242:context_->Unmap(spectralTexture_.Get(), 0);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.cpp:248:void D3D11Renderer::renderSpectralVisualization() { } // Stub for now
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:41:bool createSpectralTexture(int width, int height) override;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:42:void updateSpectralTexture(const SpectralFrame& frame) override;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:48:void renderSpectralVisualization() override;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:75:// Spectral visualization resources
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:76:Microsoft::WRL::ComPtr<ID3D11Texture2D> spectralTexture_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:77:Microsoft::WRL::ComPtr<ID3D11ShaderResourceView> spectralSRV_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:82:Microsoft::WRL::ComPtr<ID3D11PixelShader> spectralPS_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:92:int spectralWidth_ = 512;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Fixed.h:93:int spectralHeight_ = 256;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:85:bool D3D11Renderer::createSpectralTexture(int width, int height)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:87:spectralWidth_ = width;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:88:spectralHeight_ = height;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:101:HRESULT hr = device_->CreateTexture2D(&desc, nullptr, &spectralTexture_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:104:hr = device_->CreateShaderResourceView(spectralTexture_.Get(), nullptr, &spectralSRV_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:108:void D3D11Renderer::updateSpectralTexture(const SpectralFrame& frame)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:110:if (!spectralTexture_) return;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:113:HRESULT hr = deviceContext_->Map(spectralTexture_.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &mapped);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:119:for (int y = 0; y < spectralHeight_; ++y)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:121:for (int x = 0; x < spectralWidth_ && x < static_cast<int>(SpectralFrame::NUM_BINS); ++x)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:126:deviceContext_->Unmap(spectralTexture_.Get(), 0);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer_Simple.cpp:147:void D3D11Renderer::renderSpectralVisualization() { }
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:75:// Create spectral texture
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:76:if (!createSpectralTexture(spectralWidth_, spectralHeight_))
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:78:lastError_ = "Failed to create spectral texture";
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:276:// Simple spectral visualization pixel shader
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:277:const char* spectralPS = R"(
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:278:Texture2D spectralTexture : register(t0);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:281:cbuffer SpectralConstants : register(b0)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:307:float spectralValue = spectralTexture.Sample(linearSampler, texCoord).r;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:308:spectralValue = pow(spectralValue * brightness, contrast);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:310:float3 color = viridis(spectralValue);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:338:spectralPS, strlen(spectralPS), nullptr, nullptr, nullptr,
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:343:lastError_ = "Failed to compile spectral pixel shader";
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:355:hr = device_->CreatePixelShader(psBlob->GetBufferPointer(), psBlob->GetBufferSize(), nullptr, &spectralPS_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:373:cbDesc.ByteWidth = sizeof(SpectralConstants);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:374:HRESULT hr = device_->CreateBuffer(&cbDesc, nullptr, &spectralConstants_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:377:logD3D11Error(hr, "CreateBuffer (spectral constants)");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:483:bool D3D11Renderer::createSpectralTexture(int width, int height)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:485:spectralWidth_ = width;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:486:spectralHeight_ = height;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:488:// Create texture for spectral data
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:500:HRESULT hr = device_->CreateTexture2D(&texDesc, nullptr, &spectralTexture_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:503:logD3D11Error(hr, "CreateTexture2D (spectral)");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:508:hr = device_->CreateShaderResourceView(spectralTexture_.Get(), nullptr, &spectralSRV_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:511:logD3D11Error(hr, "CreateShaderResourceView (spectral)");
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:520:// Create MaskAtlas texture (same dimensions as spectral texture)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:523:texDesc.Width = spectralWidth_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:524:texDesc.Height = spectralHeight_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:559:stagingDesc.Height = spectralHeight_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:668:void D3D11Renderer::updateSpectralTexture(const SpectralFrame& frame)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:670:if (!spectralTexture_ || !deviceContext_)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:674:HRESULT hr = deviceContext_->Map(spectralTexture_.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:678:// Copy spectral magnitude data to texture
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:683:for (int y = 0; y < spectralHeight_; ++y)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:685:for (int x = 0; x < spectralWidth_ && x < static_cast<int>(SpectralFrame::NUM_BINS); ++x)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:691:deviceContext_->Unmap(spectralTexture_.Get(), 0);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:696:// Update spectral constants
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:697:if (!deviceContext_ || !spectralConstants_)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:700:HRESULT hr = deviceContext_->Map(spectralConstants_.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:703:SpectralConstants* constants = static_cast<SpectralConstants*>(mappedResource.pData);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:714:deviceContext_->Unmap(spectralConstants_.Get(), 0);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:718:void D3D11Renderer::renderSpectralVisualization()
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:725:deviceContext_->PSSetShader(spectralPS_.Get(), nullptr, 0);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:728:deviceContext_->PSSetShaderResources(0, 1, spectralSRV_.GetAddressOf());
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:730:deviceContext_->PSSetConstantBuffers(0, 1, spectralConstants_.GetAddressOf());
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:838:viewport.Width = static_cast<float>(spectralWidth_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:839:viewport.Height = static_cast<float>(spectralHeight_);
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:916:bool D3D11Renderer::readbackMaskColumn(int columnIndex, float* outputColumn, int numBins)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:918:if (!maskAtlas_ || columnIndex < 0 || columnIndex >= spectralWidth_)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:926:sourceBox.bottom = spectralHeight_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:955:for (int bin = 0; bin < numBins && bin < spectralHeight_; ++bin)
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:1008:spectralPS_.Reset();
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:1009:spectralCS_.Reset();
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.cpp:1019:spectralConstants_.Reset();
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:30:bool createSpectralTexture(int width, int height) override;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:31:void updateSpectralTexture(const SpectralFrame& frame) override;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:37:void renderSpectralVisualization() override;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:65:// Spectral visualization resources
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:66:ComPtr<ID3D11Texture2D> spectralTexture_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:67:ComPtr<ID3D11ShaderResourceView> spectralSRV_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:68:ComPtr<ID3D11UnorderedAccessView> spectralUAV_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:83:ComPtr<ID3D11PixelShader> spectralPS_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:84:ComPtr<ID3D11ComputeShader> spectralCS_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:94:struct SpectralConstants
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:124:ComPtr<ID3D11Buffer> spectralConstants_;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:152:int spectralWidth_ = 512;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:153:int spectralHeight_ = 256;
C:\spectralCanvas Pro\Source\Viz\backends\D3D11Renderer.h:183:bool readbackMaskColumn(int columnIndex, float* outputColumn, int numBins);
C:\spectralCanvas Pro\Source\Viz\GpuRenderer.h:24:virtual bool createSpectralTexture(int width, int height) = 0;
C:\spectralCanvas Pro\Source\Viz\GpuRenderer.h:25:virtual void updateSpectralTexture(const SpectralFrame& frame) = 0;
C:\spectralCanvas Pro\Source\Viz\GpuRenderer.h:33:virtual void renderSpectralVisualization() = 0;
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:36:UpdateSpectralTexture,
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:39:RenderSpectralFrame,
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:124:ComPtr<ID3D11Texture2D> dynamicSpectralTexture_;
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:125:ComPtr<ID3D11ShaderResourceView> spectralTextureSRV_;
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:167:bool createSpectralTexture(int width, int height);
C:\spectralCanvas Pro\Source\Viz\RenderThread.h:180:void renderSpectralVisualization();
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:1:#include "SpectralCanvasProAudioProcessor.h"
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:2:#include "SpectralCanvasProEditor.h"
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:5:SpectralCanvasProAudioProcessor::SpectralCanvasProAudioProcessor()
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:13:SpectralCanvasProAudioProcessor::~SpectralCanvasProAudioProcessor()
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:25:void SpectralCanvasProAudioProcessor::prepareToPlay(double sampleRate, int samplesPerBlock)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:40:// Initialize RT-safe spectral processing components
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:41:spectralEngine = std::make_unique<SpectralEngine>();
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:42:spectralEngine->initialize(sampleRate, samplesPerBlock);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:44:// Connect SampleLoader to SpectralEngine (RT-safe pointer sharing)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:45:spectralEngine->setSampleLoader(&sampleLoader);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:55:spectralDataQueue.clear();
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:57:maskColumnQueue.clear();
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:60:juce::Logger::writeToLog("[AUDIO] MaskQueue addr=" + juce::String::toHexString(reinterpret_cast<uintptr_t>(&maskColumnQueue)) + " sizeof(MaskColumn)=" + juce::String(sizeof(MaskColumn)));
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:68:spectralStub.prepare(sampleRate, fftSize, numBins, channels);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:92:void SpectralCanvasProAudioProcessor::releaseResources()
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:94:if (spectralEngine)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:95:spectralEngine->reset();
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:102:void SpectralCanvasProAudioProcessor::setAudioPathFromParams()
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:114:void SpectralCanvasProAudioProcessor::rtResetPhase4_() noexcept
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:116:spectralStub.reset(); // zero phases/magnitudes; RT-safe
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:119:void SpectralCanvasProAudioProcessor::rtResetTestFeeder_() noexcept
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:125:int SpectralCanvasProAudioProcessor::getActiveBinCount() const noexcept
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:127:return spectralStub.getActiveBinCount();
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:130:int SpectralCanvasProAudioProcessor::getNumBins() const noexcept
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:132:return spectralStub.getNumBins();
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:136:void SpectralCanvasProAudioProcessor::processBlock(juce::AudioBuffer<float>& buffer,
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:161:debugTap_.queueAddrOnAudio.store(reinterpret_cast<uintptr_t>(&maskColumnQueue), std::memory_order_relaxed);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:174:spectralStub.popAllMaskColumnsInto(maskColumnQueue); // discard all data
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:213:spectralStub.popAllMaskColumnsInto(maskColumnQueue);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:217:keyFilter.apply(spectralStub.getMagnitudesWritePtr(), 257);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:224:spectralStub.process(buffer, oscGain);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:283:void SpectralCanvasProAudioProcessor::fallbackBeep(juce::AudioBuffer<float>& buffer) noexcept
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:299:void SpectralCanvasProAudioProcessor::generateFallbackBeep(juce::AudioBuffer<float>& buffer, int numSamples) noexcept
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:323:void SpectralCanvasProAudioProcessor::parameterChanged(const juce::String& parameterID, float newValue)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:360:void SpectralCanvasProAudioProcessor::parameterChanged(const juce::String&, float)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:366:juce::AudioProcessorEditor* SpectralCanvasProAudioProcessor::createEditor()
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:368:return new SpectralCanvasProEditor(*this);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:371:void SpectralCanvasProAudioProcessor::getStateInformation(juce::MemoryBlock& destData)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:378:void SpectralCanvasProAudioProcessor::setStateInformation(const void* data, int sizeInBytes)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:388:bool SpectralCanvasProAudioProcessor::loadSampleFile(const juce::File& audioFile)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:394:void SpectralCanvasProAudioProcessor::generateImmediateAudioFeedback()
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:400:bool SpectralCanvasProAudioProcessor::pushMaskColumn(const MaskColumn& mask)
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:402:// DEBUG: Log that pushMaskColumn is being called
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:403:juce::Logger::writeToLog("*** PUSHMASKCOLUMN CALLED! *** Path=" + juce::String(static_cast<int>(getCurrentPath())));
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:409:juce::Logger::writeToLog("pushMaskColumn rejected - not Phase4 path");
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:414:juce::Logger::writeToLog("pushMaskColumn proceeding to queue...");
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:419:MaskColumnEx colEx;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:421:// Copy base MaskColumn data
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:433:const bool success = maskColumnQueue.push(colEx);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:436:debugTap_.queueAddrOnPush.store(reinterpret_cast<uintptr_t>(&maskColumnQueue), std::memory_order_relaxed);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:448:const bool success = maskColumnQueue.push(mask);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:461:int SpectralCanvasProAudioProcessor::getBlockSize() const
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:466:double SpectralCanvasProAudioProcessor::getSampleRate() const
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:471:SpectralCanvasProAudioProcessor::PerformanceMetrics SpectralCanvasProAudioProcessor::getPerformanceMetrics() const
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:480:metrics.queueDepth = maskColumnQueue.getApproxQueueDepth();
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:481:metrics.dropCount = maskColumnQueue.getDropCount();
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.cpp:495:return new SpectralCanvasProAudioProcessor();
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:9:#include "DSP/SpectralEngine.h"
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:15:#include "DSP/SpectralEngineStub.h"
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:18:class SpectralCanvasProAudioProcessor : public juce::AudioProcessor,
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:30:SpectralCanvasProAudioProcessor();
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:31:~SpectralCanvasProAudioProcessor() override;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:62:SpectralDataQueue& getSpectralDataQueue() { return spectralDataQueue; }
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:64:MaskColumnQueue& getMaskColumnQueue() { return maskColumnQueue; }
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:95:// Enhanced MaskColumn with debug sequence
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:96:struct MaskColumnEx : MaskColumn {
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:103:bool pushMaskColumn(const MaskColumn& mask);
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:117:// SpectralEngineStub diagnostics
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:118:uint64_t getMaskPopCount() const noexcept { return spectralStub.getPopCount(); }
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:119:float getMaxMagnitude() const noexcept { return spectralStub.getMaxMagnitude(); }
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:152:SpectralDataQueue spectralDataQueue;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:154:MaskColumnQueue maskColumnQueue;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:160:// RT-safe spectral processing
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:161:std::unique_ptr<SpectralEngine> spectralEngine;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:171:dsp::SpectralEngineStub spectralStub;
C:\spectralCanvas Pro\Source\SpectralCanvasProAudioProcessor.h:198:JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(SpectralCanvasProAudioProcessor)
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.cpp:1:#include "SpectralCanvasProEditor.h"
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.cpp:4:SpectralCanvasProEditor::SpectralCanvasProEditor(SpectralCanvasProAudioProcessor& p)
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.cpp:7:// Phase 2-3 Minimal UI: Top strip + full-bleed canvas
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.cpp:9:// Canvas component (full-bleed background)
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.cpp:10:canvasComponent = std::make_unique<CanvasComponent>(audioProcessor);
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.cpp:11:addAndMakeVisible(*canvasComponent);
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.cpp:23:SpectralCanvasProEditor::~SpectralCanvasProEditor()
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.cpp:26:canvasComponent.reset();
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.cpp:29:void SpectralCanvasProEditor::paint(juce::Graphics& g)
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.cpp:35:void SpectralCanvasProEditor::resized()
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.cpp:43:// Canvas gets all remaining area
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.cpp:44:canvasComponent->setBounds(bounds);
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.h:4:#include "SpectralCanvasProAudioProcessor.h"
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.h:5:#include "GUI/CanvasComponent.h"
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.h:13:* - Full-bleed CanvasComponent for painting
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.h:17:class SpectralCanvasProEditor : public juce::AudioProcessorEditor
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.h:20:SpectralCanvasProEditor(SpectralCanvasProAudioProcessor&);
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.h:21:~SpectralCanvasProEditor() override;
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.h:27:SpectralCanvasProAudioProcessor& audioProcessor;
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.h:30:std::unique_ptr<CanvasComponent> canvasComponent;
C:\spectralCanvas Pro\Source\SpectralCanvasProEditor.h:33:JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(SpectralCanvasProEditor)
C:\spectralCanvas Pro\test_processor.cpp:2:#include "Source/SpectralCanvasProAudioProcessor.h"
C:\spectralCanvas Pro\test_processor.cpp:6:std::cout << "Testing SpectralCanvas Pro processor initialization..." << std::endl;
C:\spectralCanvas Pro\test_processor.cpp:10:auto processor = std::make_unique<SpectralCanvasProAudioProcessor>();
